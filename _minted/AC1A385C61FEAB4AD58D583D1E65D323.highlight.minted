\begin{MintedVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/** \PYGZlt{}module\PYGZgt{} System Configuration}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * This module defines configuration parameters for the ORR (Observe,}
\PYG{c+cm}{ * Reorganize, Reflect) system. These parameters control the behavior of the}
\PYG{c+cm}{ * cognitive cycle, such as resource limits.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * }
\PYG{c+cm}{ * }
\PYG{c+cm}{ */}
\PYG{p}{:\PYGZhy{}} \PYG{n+nf}{module}\PYG{p}{(}\PYG{l+s+sAtom}{config}\PYG{p}{,} \PYG{p}{[}
    \PYG{l+s+sAtom}{max\PYGZus{}inferences}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{p}{,}
    \PYG{l+s+sAtom}{max\PYGZus{}retries}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{p}{,}
    \PYG{l+s+sAtom}{cognitive\PYGZus{}cost}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}
    \PYG{l+s+sAtom}{server\PYGZus{}mode}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{p}{,}
    \PYG{l+s+sAtom}{server\PYGZus{}endpoint\PYGZus{}enabled}\PYG{o}{/}\PYG{l+m+mi}{1}
    \PYG{p}{]).}

\PYG{c+c1}{\PYGZpc{}!      max\PYGZus{}inferences(?Limit:integer) is nondet.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       Defines the maximum number of inference steps the meta\PYGZhy{}interpreter}
\PYG{c+c1}{\PYGZpc{}       is allowed to take before a `resource\PYGZus{}exhaustion` perturbation is}
\PYG{c+c1}{\PYGZpc{}       triggered.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       This is a key parameter for learning. It is intentionally set to a}
\PYG{c+c1}{\PYGZpc{}       low value to make inefficient strategies (like the initial `add/3`}
\PYG{c+c1}{\PYGZpc{}       implementation) fail, thus creating a \PYGZdq{}disequilibrium\PYGZdq{} that the}
\PYG{c+c1}{\PYGZpc{}       system must resolve through reorganization.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       This predicate is dynamic, so it can be changed at runtime if needed.}
\PYG{p}{:\PYGZhy{}} \PYG{l+s+sAtom}{dynamic} \PYG{l+s+sAtom}{max\PYGZus{}inferences}\PYG{o}{/}\PYG{l+m+mf}{1.}
\PYG{n+nf}{max\PYGZus{}inferences}\PYG{p}{(}\PYG{l+m+mi}{15}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{}!      max\PYGZus{}retries(?Limit:integer) is nondet.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       Defines the maximum number of times the system will attempt to}
\PYG{c+c1}{\PYGZpc{}       reorganize and retry a goal after a failure. This prevents infinite}
\PYG{c+c1}{\PYGZpc{}       loops if the system is unable to find a stable, coherent solution.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       This predicate is dynamic.}
\PYG{p}{:\PYGZhy{}} \PYG{l+s+sAtom}{dynamic} \PYG{l+s+sAtom}{max\PYGZus{}retries}\PYG{o}{/}\PYG{l+m+mf}{1.}
\PYG{n+nf}{max\PYGZus{}retries}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} \PYGZhy{}\PYGZhy{}\PYGZhy{} Cognitive Cost Configuration \PYGZhy{}\PYGZhy{}\PYGZhy{}}

\PYG{c+c1}{\PYGZpc{}!      cognitive\PYGZus{}cost(?Action:atom, ?Cost:number) is nondet.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       Defines the fundamental unit costs of cognitive operations for the}
\PYG{c+c1}{\PYGZpc{}       embodied mathematics system. This implements the \PYGZdq{}measuring stick\PYGZdq{}}
\PYG{c+c1}{\PYGZpc{}       metaphor where computational effort represents embodied distance.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       Different actions have different cognitive costs based on their}
\PYG{c+c1}{\PYGZpc{}       embodied nature:}
\PYG{c+c1}{\PYGZpc{}       \PYGZhy{} unit\PYGZus{}count: The effort of counting one item (high effort, temporal)}
\PYG{c+c1}{\PYGZpc{}       \PYGZhy{} slide\PYGZus{}step: Moving one step on a mental number line (spatial, lower effort)}
\PYG{c+c1}{\PYGZpc{}       \PYGZhy{} fact\PYGZus{}retrieval: Accessing a known fact (compressed, minimal effort)}
\PYG{c+c1}{\PYGZpc{}       \PYGZhy{} inference: Standard logical inference (abstract reasoning)}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       This predicate is dynamic to allow learning\PYGZhy{}based cost adjustments.}
\PYG{p}{:\PYGZhy{}} \PYG{l+s+sAtom}{dynamic} \PYG{l+s+sAtom}{cognitive\PYGZus{}cost}\PYG{o}{/}\PYG{l+m+mf}{2.}

\PYG{c+c1}{\PYGZpc{} Default cost for a standard logical inference (abstract reasoning)}
\PYG{n+nf}{cognitive\PYGZus{}cost}\PYG{p}{(}\PYG{l+s+sAtom}{inference}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} Cost for an atomic, embodied counting action (temporally extended)}
\PYG{n+nf}{cognitive\PYGZus{}cost}\PYG{p}{(}\PYG{l+s+sAtom}{unit\PYGZus{}count}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} Cost for moving one unit on a mental number line (spatialized action)}
\PYG{n+nf}{cognitive\PYGZus{}cost}\PYG{p}{(}\PYG{l+s+sAtom}{slide\PYGZus{}step}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} Cost of retrieving a known fact (highly compressed, minimal effort)}
\PYG{n+nf}{cognitive\PYGZus{}cost}\PYG{p}{(}\PYG{l+s+sAtom}{fact\PYGZus{}retrieval}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} Cost for modal state transitions (embodied cognitive shifts)}
\PYG{n+nf}{cognitive\PYGZus{}cost}\PYG{p}{(}\PYG{l+s+sAtom}{modal\PYGZus{}shift}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} Cost for normative checking (validating against mathematical context)}
\PYG{n+nf}{cognitive\PYGZus{}cost}\PYG{p}{(}\PYG{l+s+sAtom}{norm\PYGZus{}check}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} \PYGZhy{}\PYGZhy{}\PYGZhy{} Server Configuration \PYGZhy{}\PYGZhy{}\PYGZhy{}}

\PYG{c+c1}{\PYGZpc{}!      server\PYGZus{}mode(?Mode:atom) is nondet.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       Defines the current server mode which controls which endpoints}
\PYG{c+c1}{\PYGZpc{}       and features are available.}
\PYG{c+c1}{\PYGZpc{}       \PYGZhy{} development: Full debugging and analysis endpoints}
\PYG{c+c1}{\PYGZpc{}       \PYGZhy{} production: Full\PYGZhy{}featured production server with all core endpoints}
\PYG{c+c1}{\PYGZpc{}       \PYGZhy{} testing: Limited endpoints for automated testing  }
\PYG{c+c1}{\PYGZpc{}       \PYGZhy{} simple: Self\PYGZhy{}contained endpoints without module dependencies}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       This predicate is dynamic to allow runtime reconfiguration.}
\PYG{p}{:\PYGZhy{}} \PYG{l+s+sAtom}{dynamic} \PYG{l+s+sAtom}{server\PYGZus{}mode}\PYG{o}{/}\PYG{l+m+mf}{1.}
\PYG{n+nf}{server\PYGZus{}mode}\PYG{p}{(}\PYG{l+s+sAtom}{development}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{}!      server\PYGZus{}endpoint\PYGZus{}enabled(?Endpoint:atom) is nondet.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       Defines which endpoints are enabled based on the current server mode.}
\PYG{c+c1}{\PYGZpc{}       This allows fine\PYGZhy{}grained control over API availability.}
\PYG{p}{:\PYGZhy{}} \PYG{l+s+sAtom}{dynamic} \PYG{l+s+sAtom}{server\PYGZus{}endpoint\PYGZus{}enabled}\PYG{o}{/}\PYG{l+m+mf}{1.}

\PYG{c+c1}{\PYGZpc{} Production mode: Core endpoints for deployment}
\PYG{n+nf}{server\PYGZus{}endpoint\PYGZus{}enabled}\PYG{p}{(}\PYG{l+s+sAtom}{solve}\PYG{p}{)} \PYG{p}{:\PYGZhy{}} \PYG{n+nf}{server\PYGZus{}mode}\PYG{p}{(}\PYG{l+s+sAtom}{production}\PYG{p}{).}
\PYG{n+nf}{server\PYGZus{}endpoint\PYGZus{}enabled}\PYG{p}{(}\PYG{l+s+sAtom}{analyze\PYGZus{}semantics}\PYG{p}{)} \PYG{p}{:\PYGZhy{}} \PYG{n+nf}{server\PYGZus{}mode}\PYG{p}{(}\PYG{l+s+sAtom}{production}\PYG{p}{).}
\PYG{n+nf}{server\PYGZus{}endpoint\PYGZus{}enabled}\PYG{p}{(}\PYG{l+s+sAtom}{analyze\PYGZus{}strategy}\PYG{p}{)} \PYG{p}{:\PYGZhy{}} \PYG{n+nf}{server\PYGZus{}mode}\PYG{p}{(}\PYG{l+s+sAtom}{production}\PYG{p}{).}
\PYG{n+nf}{server\PYGZus{}endpoint\PYGZus{}enabled}\PYG{p}{(}\PYG{l+s+sAtom}{execute\PYGZus{}orr}\PYG{p}{)} \PYG{p}{:\PYGZhy{}} \PYG{n+nf}{server\PYGZus{}mode}\PYG{p}{(}\PYG{l+s+sAtom}{production}\PYG{p}{).}
\PYG{n+nf}{server\PYGZus{}endpoint\PYGZus{}enabled}\PYG{p}{(}\PYG{l+s+sAtom}{get\PYGZus{}reorganization\PYGZus{}log}\PYG{p}{)} \PYG{p}{:\PYGZhy{}} \PYG{n+nf}{server\PYGZus{}mode}\PYG{p}{(}\PYG{l+s+sAtom}{production}\PYG{p}{).}
\PYG{n+nf}{server\PYGZus{}endpoint\PYGZus{}enabled}\PYG{p}{(}\PYG{l+s+sAtom}{cognitive\PYGZus{}cost}\PYG{p}{)} \PYG{p}{:\PYGZhy{}} \PYG{n+nf}{server\PYGZus{}mode}\PYG{p}{(}\PYG{l+s+sAtom}{production}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} Development mode: All endpoints enabled}
\PYG{n+nf}{server\PYGZus{}endpoint\PYGZus{}enabled}\PYG{p}{(}\PYG{l+s+sAtom}{solve}\PYG{p}{)} \PYG{p}{:\PYGZhy{}} \PYG{n+nf}{server\PYGZus{}mode}\PYG{p}{(}\PYG{l+s+sAtom}{development}\PYG{p}{).}
\PYG{n+nf}{server\PYGZus{}endpoint\PYGZus{}enabled}\PYG{p}{(}\PYG{l+s+sAtom}{analyze\PYGZus{}semantics}\PYG{p}{)} \PYG{p}{:\PYGZhy{}} \PYG{n+nf}{server\PYGZus{}mode}\PYG{p}{(}\PYG{l+s+sAtom}{development}\PYG{p}{).}
\PYG{n+nf}{server\PYGZus{}endpoint\PYGZus{}enabled}\PYG{p}{(}\PYG{l+s+sAtom}{analyze\PYGZus{}strategy}\PYG{p}{)} \PYG{p}{:\PYGZhy{}} \PYG{n+nf}{server\PYGZus{}mode}\PYG{p}{(}\PYG{l+s+sAtom}{development}\PYG{p}{).}
\PYG{n+nf}{server\PYGZus{}endpoint\PYGZus{}enabled}\PYG{p}{(}\PYG{l+s+sAtom}{execute\PYGZus{}orr}\PYG{p}{)} \PYG{p}{:\PYGZhy{}} \PYG{n+nf}{server\PYGZus{}mode}\PYG{p}{(}\PYG{l+s+sAtom}{development}\PYG{p}{).}
\PYG{n+nf}{server\PYGZus{}endpoint\PYGZus{}enabled}\PYG{p}{(}\PYG{l+s+sAtom}{get\PYGZus{}reorganization\PYGZus{}log}\PYG{p}{)} \PYG{p}{:\PYGZhy{}} \PYG{n+nf}{server\PYGZus{}mode}\PYG{p}{(}\PYG{l+s+sAtom}{development}\PYG{p}{).}
\PYG{n+nf}{server\PYGZus{}endpoint\PYGZus{}enabled}\PYG{p}{(}\PYG{l+s+sAtom}{cognitive\PYGZus{}cost}\PYG{p}{)} \PYG{p}{:\PYGZhy{}} \PYG{n+nf}{server\PYGZus{}mode}\PYG{p}{(}\PYG{l+s+sAtom}{development}\PYG{p}{).}
\PYG{n+nf}{server\PYGZus{}endpoint\PYGZus{}enabled}\PYG{p}{(}\PYG{l+s+sAtom}{debug\PYGZus{}trace}\PYG{p}{)} \PYG{p}{:\PYGZhy{}} \PYG{n+nf}{server\PYGZus{}mode}\PYG{p}{(}\PYG{l+s+sAtom}{development}\PYG{p}{).}
\PYG{n+nf}{server\PYGZus{}endpoint\PYGZus{}enabled}\PYG{p}{(}\PYG{l+s+sAtom}{modal\PYGZus{}analysis}\PYG{p}{)} \PYG{p}{:\PYGZhy{}} \PYG{n+nf}{server\PYGZus{}mode}\PYG{p}{(}\PYG{l+s+sAtom}{development}\PYG{p}{).}
\PYG{n+nf}{server\PYGZus{}endpoint\PYGZus{}enabled}\PYG{p}{(}\PYG{l+s+sAtom}{stress\PYGZus{}analysis}\PYG{p}{)} \PYG{p}{:\PYGZhy{}} \PYG{n+nf}{server\PYGZus{}mode}\PYG{p}{(}\PYG{l+s+sAtom}{development}\PYG{p}{).}
\PYG{n+nf}{server\PYGZus{}endpoint\PYGZus{}enabled}\PYG{p}{(}\PYG{l+s+sAtom}{test\PYGZus{}grounded\PYGZus{}arithmetic}\PYG{p}{)} \PYG{p}{:\PYGZhy{}} \PYG{n+nf}{server\PYGZus{}mode}\PYG{p}{(}\PYG{l+s+sAtom}{development}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} Testing mode: Minimal endpoints for validation}
\PYG{n+nf}{server\PYGZus{}endpoint\PYGZus{}enabled}\PYG{p}{(}\PYG{l+s+sAtom}{test}\PYG{p}{)} \PYG{p}{:\PYGZhy{}} \PYG{n+nf}{server\PYGZus{}mode}\PYG{p}{(}\PYG{l+s+sAtom}{testing}\PYG{p}{).}
\PYG{n+nf}{server\PYGZus{}endpoint\PYGZus{}enabled}\PYG{p}{(}\PYG{l+s+sAtom}{health}\PYG{p}{)} \PYG{p}{:\PYGZhy{}} \PYG{n+nf}{server\PYGZus{}mode}\PYG{p}{(}\PYG{l+s+sAtom}{testing}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} Simple mode: Self\PYGZhy{}contained endpoints}
\PYG{n+nf}{server\PYGZus{}endpoint\PYGZus{}enabled}\PYG{p}{(}\PYG{l+s+sAtom}{analyze\PYGZus{}semantics}\PYG{p}{)} \PYG{p}{:\PYGZhy{}} \PYG{n+nf}{server\PYGZus{}mode}\PYG{p}{(}\PYG{l+s+sAtom}{simple}\PYG{p}{).}
\PYG{n+nf}{server\PYGZus{}endpoint\PYGZus{}enabled}\PYG{p}{(}\PYG{l+s+sAtom}{analyze\PYGZus{}strategy}\PYG{p}{)} \PYG{p}{:\PYGZhy{}} \PYG{n+nf}{server\PYGZus{}mode}\PYG{p}{(}\PYG{l+s+sAtom}{simple}\PYG{p}{).}
\PYG{n+nf}{server\PYGZus{}endpoint\PYGZus{}enabled}\PYG{p}{(}\PYG{l+s+sAtom}{test}\PYG{p}{)} \PYG{p}{:\PYGZhy{}} \PYG{n+nf}{server\PYGZus{}mode}\PYG{p}{(}\PYG{l+s+sAtom}{simple}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} Production mode: Minimal endpoints}
\PYG{n+nf}{server\PYGZus{}endpoint\PYGZus{}enabled}\PYG{p}{(}\PYG{l+s+sAtom}{solve}\PYG{p}{)} \PYG{p}{:\PYGZhy{}} \PYG{n+nf}{server\PYGZus{}mode}\PYG{p}{(}\PYG{l+s+sAtom}{production}\PYG{p}{).}
\end{MintedVerbatim}
