\begin{MintedVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/** \PYGZlt{}module\PYGZgt{} Tracing Meta\PYGZhy{}Interpreter for Observation}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * This module provides the core \PYGZdq{}Observe\PYGZdq{} capability of the ORR cycle.}
\PYG{c+cm}{ * It contains a meta\PYGZhy{}interpreter, `solve/4`, which executes goals defined}
\PYG{c+cm}{ * in the `object\PYGZus{}level` module.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * Instead of just succeeding or failing, this meta\PYGZhy{}interpreter produces a}
\PYG{c+cm}{ * detailed `Trace` of the execution path. This trace includes which clauses}
\PYG{c+cm}{ * were used, which built\PYGZhy{}in predicates were called, and where failures}
\PYG{c+cm}{ * occurred. The trace is the primary data source for the `reflective\PYGZus{}monitor`.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * The interpreter also includes a simple resource constraint (a maximum}
\PYG{c+cm}{ * number of inferences) to prevent infinite loops, throwing a `perturbation`}
\PYG{c+cm}{ * exception if the limit is exceeded.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * @author Tilo Wiedera}
\PYG{c+cm}{ * @license MIT}
\PYG{c+cm}{ */}
\PYG{p}{:\PYGZhy{}} \PYG{n+nf}{module}\PYG{p}{(}\PYG{l+s+sAtom}{meta\PYGZus{}interpreter}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+sAtom}{solve}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{]).}
\PYG{p}{:\PYGZhy{}} \PYG{n+nf}{use\PYGZus{}module}\PYG{p}{(}\PYG{l+s+sAtom}{object\PYGZus{}level}\PYG{p}{).} \PYG{c+c1}{\PYGZpc{} Ensure we can access the object\PYGZhy{}level code}

\PYG{c+c1}{\PYGZpc{}!      solve(+Goal, +InferencesIn, \PYGZhy{}InferencesOut, \PYGZhy{}Trace) is nondet.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       Executes a given `Goal` and produces a `Trace` of the execution.}
\PYG{c+c1}{\PYGZpc{}       This is the core predicate of the meta\PYGZhy{}interpreter. It handles}
\PYG{c+c1}{\PYGZpc{}       different types of goals (conjunctions, built\PYGZhy{}ins, object\PYGZhy{}level}
\PYG{c+c1}{\PYGZpc{}       clauses) and tracks the number of inferences to prevent run\PYGZhy{}away}
\PYG{c+c1}{\PYGZpc{}       execution.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       The `Trace` is a list of events, which can be:}
\PYG{c+c1}{\PYGZpc{}       \PYGZhy{} `trace(Goal, SubTrace)`: For a subgoal.}
\PYG{c+c1}{\PYGZpc{}       \PYGZhy{} `call(Goal)`: For a successful call to a built\PYGZhy{}in predicate.}
\PYG{c+c1}{\PYGZpc{}       \PYGZhy{} `clause(Clause)`: For the successful application of an object\PYGZhy{}level clause.}
\PYG{c+c1}{\PYGZpc{}       \PYGZhy{} `fail(Goal)`: When a goal fails (no matching clauses).}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       @param Goal The goal to be solved.}
\PYG{c+c1}{\PYGZpc{}       @param InferencesIn The initial number of available inference steps.}
\PYG{c+c1}{\PYGZpc{}       @param InferencesOut The remaining number of inference steps.}
\PYG{c+c1}{\PYGZpc{}       @param Trace A list representing the execution trace.}
\PYG{c+c1}{\PYGZpc{}       @error perturbation(resource\PYGZus{}exhaustion) if the inference counter drops to zero.}

\PYG{c+c1}{\PYGZpc{} Base case: `true` always succeeds with an empty trace.}
\PYG{n+nf}{solve}\PYG{p}{(}\PYG{l+s+sAtom}{true}\PYG{p}{,} \PYG{n+nv}{I}\PYG{p}{,} \PYG{n+nv}{I}\PYG{p}{,} \PYG{p}{[])} \PYG{p}{:\PYGZhy{}} \PYG{p}{!.}

\PYG{c+c1}{\PYGZpc{} Conjunction: Solve `A` then `B`. The trace is a combination of the two sub\PYGZhy{}traces.}
\PYG{n+nf}{solve}\PYG{p}{((}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{),} \PYG{n+nv}{I\PYGZus{}In}\PYG{p}{,} \PYG{n+nv}{I\PYGZus{}Out}\PYG{p}{,} \PYG{p}{[}\PYG{n+nf}{trace}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{A\PYGZus{}Trace}\PYG{p}{),} \PYG{n+nf}{trace}\PYG{p}{(}\PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{B\PYGZus{}Trace}\PYG{p}{)])} \PYG{p}{:\PYGZhy{}}
    \PYG{p}{!,}
    \PYG{n+nf}{solve}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{I\PYGZus{}In}\PYG{p}{,} \PYG{n+nv}{I\PYGZus{}Mid}\PYG{p}{,} \PYG{n+nv}{A\PYGZus{}Trace}\PYG{p}{),}
    \PYG{n+nf}{solve}\PYG{p}{(}\PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{I\PYGZus{}Mid}\PYG{p}{,} \PYG{n+nv}{I\PYGZus{}Out}\PYG{p}{,} \PYG{n+nv}{B\PYGZus{}Trace}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} System predicates: Check resources, execute the built\PYGZhy{}in, and record the call in the trace.}
\PYG{n+nf}{solve}\PYG{p}{(}\PYG{n+nv}{Goal}\PYG{p}{,} \PYG{n+nv}{I\PYGZus{}In}\PYG{p}{,} \PYG{n+nv}{I\PYGZus{}Out}\PYG{p}{,} \PYG{p}{[}\PYG{n+nf}{call}\PYG{p}{(}\PYG{n+nv}{Goal}\PYG{p}{)])} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{predicate\PYGZus{}property}\PYG{p}{(}\PYG{n+nv}{Goal}\PYG{p}{,} \PYG{l+s+sAtom}{built\PYGZus{}in}\PYG{p}{),}
    \PYG{p}{!,}
    \PYG{n+nf}{check\PYGZus{}viability}\PYG{p}{(}\PYG{n+nv}{I\PYGZus{}In}\PYG{p}{),}
    \PYG{n+nv}{I\PYGZus{}Out} \PYG{o}{is} \PYG{n+nv}{I\PYGZus{}In} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,}
    \PYG{n+nf}{call}\PYG{p}{(}\PYG{n+nv}{Goal}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} Object\PYGZhy{}level predicates: Find a matching clause in the `object\PYGZus{}level` module,}
\PYG{c+c1}{\PYGZpc{} record its use, and recursively solve its body. This is the core of observation.}
\PYG{n+nf}{solve}\PYG{p}{(}\PYG{n+nv}{Goal}\PYG{p}{,} \PYG{n+nv}{I\PYGZus{}In}\PYG{p}{,} \PYG{n+nv}{I\PYGZus{}Out}\PYG{p}{,} \PYG{p}{[}\PYG{n+nf}{clause}\PYG{p}{(}\PYG{l+s+sAtom}{object\PYGZus{}level:}\PYG{p}{(}\PYG{n+nv}{Goal}\PYG{p}{:\PYGZhy{}}\PYG{n+nv}{Body}\PYG{p}{)),} \PYG{n+nf}{trace}\PYG{p}{(}\PYG{n+nv}{Body}\PYG{p}{,} \PYG{n+nv}{BodyTrace}\PYG{p}{)])} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{check\PYGZus{}viability}\PYG{p}{(}\PYG{n+nv}{I\PYGZus{}In}\PYG{p}{),}
    \PYG{n+nv}{I\PYGZus{}Mid} \PYG{o}{is} \PYG{n+nv}{I\PYGZus{}In} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,}
    \PYG{n+nf}{clause}\PYG{p}{(}\PYG{l+s+sAtom}{object\PYGZus{}level:}\PYG{n+nv}{Goal}\PYG{p}{,} \PYG{n+nv}{Body}\PYG{p}{),}
    \PYG{n+nf}{solve}\PYG{p}{(}\PYG{n+nv}{Body}\PYG{p}{,} \PYG{n+nv}{I\PYGZus{}Mid}\PYG{p}{,} \PYG{n+nv}{I\PYGZus{}Out}\PYG{p}{,} \PYG{n+nv}{BodyTrace}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} Failure case: If a goal is not a built\PYGZhy{}in and has no matching clauses,}
\PYG{c+c1}{\PYGZpc{} record the failure in the trace. This makes backtracking an observable event.}
\PYG{n+nf}{solve}\PYG{p}{(}\PYG{n+nv}{Goal}\PYG{p}{,} \PYG{n+nv}{I}\PYG{p}{,} \PYG{n+nv}{I}\PYG{p}{,} \PYG{p}{[}\PYG{n+nf}{fail}\PYG{p}{(}\PYG{n+nv}{Goal}\PYG{p}{)])} \PYG{p}{:\PYGZhy{}}
    \PYG{l+s+sAtom}{\PYGZbs{}+} \PYG{n+nf}{predicate\PYGZus{}property}\PYG{p}{(}\PYG{n+nv}{Goal}\PYG{p}{,} \PYG{l+s+sAtom}{built\PYGZus{}in}\PYG{p}{),}
    \PYG{l+s+sAtom}{\PYGZbs{}+} \PYG{n+nf}{clause}\PYG{p}{(}\PYG{l+s+sAtom}{object\PYGZus{}level:}\PYG{n+nv}{Goal}\PYG{p}{,} \PYG{k}{\PYGZus{}}\PYG{p}{),} \PYG{p}{!.}


\PYG{c+c1}{\PYGZpc{} \PYGZhy{}\PYGZhy{}\PYGZhy{} Viability Check \PYGZhy{}\PYGZhy{}\PYGZhy{}}

\PYG{c+c1}{\PYGZpc{} check\PYGZus{}viability(+Inferences)}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{} Succeeds if the inference counter is positive. Throws a `perturbation`}
\PYG{c+c1}{\PYGZpc{} exception otherwise, which is caught by the execution handler.}
\PYG{n+nf}{check\PYGZus{}viability}\PYG{p}{(}\PYG{n+nv}{I}\PYG{p}{)} \PYG{p}{:\PYGZhy{}} \PYG{n+nv}{I} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{p}{!.}
\PYG{n+nf}{check\PYGZus{}viability}\PYG{p}{(}\PYG{k}{\PYGZus{}}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{c+c1}{\PYGZpc{} Constraint violated: PERTURBATION DETECTED}
    \PYG{n+nf}{throw}\PYG{p}{(}\PYG{n+nf}{perturbation}\PYG{p}{(}\PYG{l+s+sAtom}{resource\PYGZus{}exhaustion}\PYG{p}{)).}
\end{MintedVerbatim}
