\begin{MintedVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/** \PYGZlt{}module\PYGZgt{} More Machine Learner (Protein Folding Analogy)}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * This module implements a machine learning system inspired by protein folding,}
\PYG{c+cm}{ * where a system seeks a lower\PYGZhy{}energy, more efficient state. It learns new,}
\PYG{c+cm}{ * more efficient arithmetic strategies by observing the execution traces of}
\PYG{c+cm}{ * less efficient ones.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * The core components are:}
\PYG{c+cm}{ * 1.  **A Foundational Solver**: The most basic, inefficient way to solve a}
\PYG{c+cm}{ *     problem (e.g., counting on by ones). This is the \PYGZdq{}unfolded\PYGZdq{} state.}
\PYG{c+cm}{ * 2.  **A Strategy Hierarchy**: A dynamic knowledge base of `run\PYGZus{}learned\PYGZus{}strategy/5`}
\PYG{c+cm}{ *     clauses. The system always tries the most \PYGZdq{}folded\PYGZdq{} (efficient) strategies first.}
\PYG{c+cm}{ * 3.  **A Generative\PYGZhy{}Reflective Loop (`explore/1`)**:}
\PYG{c+cm}{ *     \PYGZhy{} **Generative Phase**: Solves a problem using the current best strategy.}
\PYG{c+cm}{ *     \PYGZhy{} **Reflective Phase**: Analyzes the execution trace of the solution,}
\PYG{c+cm}{ *       looking for patterns that suggest a more efficient strategy (a \PYGZdq{}fold\PYGZdq{}).}
\PYG{c+cm}{ * 4.  **Pattern Detection \PYGZam{} Construction**: Specific predicates that detect}
\PYG{c+cm}{ *     patterns (e.g., commutativity, making a 10) and construct new, more}
\PYG{c+cm}{ *     efficient strategy clauses. These new clauses are then asserted into}
\PYG{c+cm}{ *     the knowledge base.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * @author Tilo Wiedera}
\PYG{c+cm}{ * @license MIT}
\PYG{c+cm}{ */}
\PYG{p}{:\PYGZhy{}} \PYG{n+nf}{module}\PYG{p}{(}\PYG{l+s+sAtom}{more\PYGZus{}machine\PYGZus{}learner}\PYG{p}{,}
          \PYG{p}{[} \PYG{l+s+sAtom}{critique\PYGZus{}and\PYGZus{}bootstrap}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{p}{,}
            \PYG{l+s+sAtom}{explore}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{p}{,}
            \PYG{l+s+sAtom}{run\PYGZus{}learned\PYGZus{}strategy}\PYG{o}{/}\PYG{l+m+mi}{5}\PYG{p}{,}
            \PYG{l+s+sAtom}{solve}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,}
            \PYG{l+s+sAtom}{save\PYGZus{}knowledge}\PYG{o}{/}\PYG{l+m+mi}{0}
          \PYG{p}{]).}

\PYG{c+c1}{\PYGZpc{} Use the semantics engine for validation}
\PYG{p}{:\PYGZhy{}} \PYG{n+nf}{use\PYGZus{}module}\PYG{p}{(}\PYG{l+s+sAtom}{incompatibility\PYGZus{}semantics}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+sAtom}{proves}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+sAtom}{set\PYGZus{}domain}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+sAtom}{current\PYGZus{}domain}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+sAtom}{obj\PYGZus{}coll}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+sAtom}{normalize}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{]).}
\PYG{p}{:\PYGZhy{}} \PYG{n+nf}{use\PYGZus{}module}\PYG{p}{(}\PYG{n+nf}{library}\PYG{p}{(}\PYG{l+s+sAtom}{random}\PYG{p}{)).}
\PYG{p}{:\PYGZhy{}} \PYG{n+nf}{use\PYGZus{}module}\PYG{p}{(}\PYG{n+nf}{library}\PYG{p}{(}\PYG{l+s+sAtom}{lists}\PYG{p}{)).}

\PYG{c+c1}{\PYGZpc{} Ensure operators are visible}
\PYG{p}{:\PYGZhy{}} \PYG{n+nf}{op}\PYG{p}{(}\PYG{l+m+mi}{1050}\PYG{p}{,} \PYG{l+s+sAtom}{xfy}\PYG{p}{,} \PYG{l+s+sAtom}{=\PYGZgt{}}\PYG{p}{).}
\PYG{p}{:\PYGZhy{}} \PYG{n+nf}{op}\PYG{p}{(}\PYG{l+m+mi}{500}\PYG{p}{,} \PYG{l+s+sAtom}{fx}\PYG{p}{,} \PYG{l+s+sAtom}{neg}\PYG{p}{).}
\PYG{p}{:\PYGZhy{}} \PYG{n+nf}{op}\PYG{p}{(}\PYG{l+m+mi}{550}\PYG{p}{,} \PYG{l+s+sAtom}{xfy}\PYG{p}{,} \PYG{l+s+sAtom}{rdiv}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{}!      run\PYGZus{}learned\PYGZus{}strategy(?A, ?B, ?Result, ?StrategyName, ?Trace) is nondet.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       A dynamic, multifile predicate that stores the collection of learned}
\PYG{c+c1}{\PYGZpc{}       strategies. Each clause of this predicate represents a single, efficient}
\PYG{c+c1}{\PYGZpc{}       strategy that the system has discovered and validated.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       The `solve/4` predicate queries this predicate first, implementing a}
\PYG{c+c1}{\PYGZpc{}       hierarchy where learned, efficient strategies are preferred over}
\PYG{c+c1}{\PYGZpc{}       foundational, inefficient ones.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       @param A The first input number.}
\PYG{c+c1}{\PYGZpc{}       @param B The second input number.}
\PYG{c+c1}{\PYGZpc{}       @param Result The result of the calculation.}
\PYG{c+c1}{\PYGZpc{}       @param StrategyName An atom identifying the learned strategy (e.g., `cob`, `rmb(10)`).}
\PYG{c+c1}{\PYGZpc{}       @param Trace A structured term representing the efficient execution path.}
\PYG{p}{:\PYGZhy{}} \PYG{l+s+sAtom}{dynamic} \PYG{l+s+sAtom}{run\PYGZus{}learned\PYGZus{}strategy}\PYG{o}{/}\PYG{l+m+mf}{5.}

\PYG{c+c1}{\PYGZpc{} =================================================================}
\PYG{c+c1}{\PYGZpc{} Part 0: Initialization and Persistence}
\PYG{c+c1}{\PYGZpc{} =================================================================}

\PYG{n+nf}{knowledge\PYGZus{}file}\PYG{p}{(}\PYG{l+s+sAtom}{\PYGZsq{}learned\PYGZus{}knowledge.pl\PYGZsq{}}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} Load persistent knowledge when this module is loaded.}
\PYG{n+nf}{load\PYGZus{}knowledge} \PYG{o}{:\PYGZhy{}}
    \PYG{n+nf}{knowledge\PYGZus{}file}\PYG{p}{(}\PYG{n+nv}{File}\PYG{p}{),}
    \PYG{p}{(}   \PYG{n+nf}{exists\PYGZus{}file}\PYG{p}{(}\PYG{n+nv}{File}\PYG{p}{)}
    \PYG{l+s+sAtom}{\PYGZhy{}\PYGZgt{}}  \PYG{n+nf}{consult}\PYG{p}{(}\PYG{n+nv}{File}\PYG{p}{),}
        \PYG{n+nf}{findall}\PYG{p}{(}\PYG{k}{\PYGZus{}}\PYG{p}{,} \PYG{n+nf}{clause}\PYG{p}{(}\PYG{n+nf}{run\PYGZus{}learned\PYGZus{}strategy}\PYG{p}{(}\PYG{k}{\PYGZus{}}\PYG{p}{,}\PYG{k}{\PYGZus{}}\PYG{p}{,}\PYG{k}{\PYGZus{}}\PYG{p}{,}\PYG{k}{\PYGZus{}}\PYG{p}{,}\PYG{k}{\PYGZus{}}\PYG{p}{),} \PYG{k}{\PYGZus{}}\PYG{p}{),} \PYG{n+nv}{Clauses}\PYG{p}{),}
        \PYG{n+nf}{length}\PYG{p}{(}\PYG{n+nv}{Clauses}\PYG{p}{,} \PYG{n+nv}{Count}\PYG{p}{),}
        \PYG{n+nf}{format}\PYG{p}{(}\PYG{l+s+sAtom}{\PYGZsq{}\PYGZti{}N[Learner Init] Successfully loaded \PYGZti{}w learned strategies.\PYGZti{}n\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{n+nv}{Count}\PYG{p}{])}
    \PYG{p}{;}   \PYG{n+nf}{format}\PYG{p}{(}\PYG{l+s+sAtom}{\PYGZsq{}\PYGZti{}N[Learner Init] Knowledge file not found. Starting fresh.\PYGZti{}n\PYGZsq{}}\PYG{p}{)}
    \PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} Ensure initialization runs after the predicate is defined}
\PYG{p}{:\PYGZhy{}} \PYG{n+nf}{initialization}\PYG{p}{(}\PYG{l+s+sAtom}{load\PYGZus{}knowledge}\PYG{p}{,} \PYG{l+s+sAtom}{now}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{}!      save\PYGZus{}knowledge is det.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       Saves all currently learned strategies (clauses of the dynamic}
\PYG{c+c1}{\PYGZpc{}       `run\PYGZus{}learned\PYGZus{}strategy/5` predicate) to the file specified by}
\PYG{c+c1}{\PYGZpc{}       `knowledge\PYGZus{}file/1`. This allows for persistence of learning across sessions.}
\PYG{n+nf}{save\PYGZus{}knowledge} \PYG{o}{:\PYGZhy{}}
    \PYG{n+nf}{knowledge\PYGZus{}file}\PYG{p}{(}\PYG{n+nv}{File}\PYG{p}{),}
    \PYG{n+nf}{setup\PYGZus{}call\PYGZus{}cleanup}\PYG{p}{(}
        \PYG{n+nf}{open}\PYG{p}{(}\PYG{n+nv}{File}\PYG{p}{,} \PYG{l+s+sAtom}{write}\PYG{p}{,} \PYG{n+nv}{Stream}\PYG{p}{),}
        \PYG{p}{(}
            \PYG{n+nf}{writeln}\PYG{p}{(}\PYG{n+nv}{Stream}\PYG{p}{,} \PYG{l+s+sAtom}{\PYGZsq{}\PYGZpc{} Automatically generated knowledge base.\PYGZsq{}}\PYG{p}{),}
            \PYG{n+nf}{writeln}\PYG{p}{(}\PYG{n+nv}{Stream}\PYG{p}{,} \PYG{l+s+sAtom}{\PYGZsq{}:\PYGZhy{} op(550, xfy, rdiv).\PYGZsq{}}\PYG{p}{),}
            \PYG{n+nf}{forall}\PYG{p}{(}\PYG{n+nf}{clause}\PYG{p}{(}\PYG{n+nf}{run\PYGZus{}learned\PYGZus{}strategy}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{R}\PYG{p}{,} \PYG{n+nv}{S}\PYG{p}{,} \PYG{n+nv}{T}\PYG{p}{),} \PYG{n+nv}{Body}\PYG{p}{),}
                   \PYG{n+nf}{portray\PYGZus{}clause}\PYG{p}{(}\PYG{n+nv}{Stream}\PYG{p}{,} \PYG{p}{(}\PYG{n+nf}{run\PYGZus{}learned\PYGZus{}strategy}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{R}\PYG{p}{,} \PYG{n+nv}{S}\PYG{p}{,} \PYG{n+nv}{T}\PYG{p}{)} \PYG{p}{:\PYGZhy{}} \PYG{n+nv}{Body}\PYG{p}{)))}
        \PYG{p}{),}
        \PYG{n+nf}{close}\PYG{p}{(}\PYG{n+nv}{Stream}\PYG{p}{)}
    \PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} =================================================================}
\PYG{c+c1}{\PYGZpc{} Part 1: The Generative\PYGZhy{}Reflective Loop (Exploration)}
\PYG{c+c1}{\PYGZpc{} =================================================================}

\PYG{c+c1}{\PYGZpc{}!      explore(+Domain:atom) is det.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       Initiates a session of autonomous exploration and learning for a}
\PYG{c+c1}{\PYGZpc{}       given domain.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       It repeatedly generates random problems, solves them using the current}
\PYG{c+c1}{\PYGZpc{}       best strategy, and then reflects on the solution trace to discover}
\PYG{c+c1}{\PYGZpc{}       and assert new, more efficient strategies.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       @param Domain The domain to explore (currently only `addition` is supported).}
\PYG{n+nf}{explore}\PYG{p}{(}\PYG{l+s+sAtom}{addition}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{writeln}\PYG{p}{(}\PYG{l+s+sAtom}{\PYGZsq{}=====================================================\PYGZsq{}}\PYG{p}{),}
    \PYG{n+nf}{writeln}\PYG{p}{(}\PYG{l+s+sAtom}{\PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{} Autonomous Exploration Initiated: Addition (Protein Folding) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZsq{}}\PYG{p}{),}
    \PYG{n+nf}{current\PYGZus{}domain}\PYG{p}{(}\PYG{n+nv}{D}\PYG{p}{),}
    \PYG{n+nf}{format}\PYG{p}{(}\PYG{l+s+sAtom}{\PYGZsq{}Current Semantic Domain: \PYGZti{}w\PYGZti{}n\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{n+nv}{D}\PYG{p}{]),}
    \PYG{p}{(}\PYG{n+nf}{member}\PYG{p}{(}\PYG{n+nv}{D}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+sAtom}{n}\PYG{p}{,} \PYG{l+s+sAtom}{z}\PYG{p}{,} \PYG{l+s+sAtom}{q}\PYG{p}{])} \PYG{l+s+sAtom}{\PYGZhy{}\PYGZgt{}}
        \PYG{n+nf}{explore\PYGZus{}addition\PYGZus{}loop}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}
    \PYG{p}{;}
        \PYG{n+nf}{writeln}\PYG{p}{(}\PYG{l+s+sAtom}{\PYGZsq{}Exploration requires domain (n, z, or q).\PYGZsq{}}\PYG{p}{)}
    \PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} explore\PYGZus{}addition\PYGZus{}loop(+N)}
\PYG{c+c1}{\PYGZpc{} The main loop for the exploration process.}
\PYG{n+nf}{explore\PYGZus{}addition\PYGZus{}loop}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{writeln}\PYG{p}{(}\PYG{l+s+sAtom}{\PYGZsq{}\PYGZbs{}nExploration limit reached. Saving knowledge base...\PYGZsq{}}\PYG{p}{),}
    \PYG{l+s+sAtom}{save\PYGZus{}knowledge}\PYG{p}{,}
    \PYG{n+nf}{writeln}\PYG{p}{(}\PYG{l+s+sAtom}{\PYGZsq{}Knowledge base saved.\PYGZsq{}}\PYG{p}{),}
    \PYG{n+nf}{writeln}\PYG{p}{(}\PYG{l+s+sAtom}{\PYGZsq{}=====================================================\PYGZsq{}}\PYG{p}{),} \PYG{p}{!.}
\PYG{n+nf}{explore\PYGZus{}addition\PYGZus{}loop}\PYG{p}{(}\PYG{n+nv}{I}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{generate\PYGZus{}addition\PYGZus{}problem}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{),}
    \PYG{n+nf}{normalize}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{AN}\PYG{p}{),} \PYG{n+nf}{normalize}\PYG{p}{(}\PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{BN}\PYG{p}{),}
    \PYG{n+nf}{format}\PYG{p}{(}\PYG{l+s+sAtom}{\PYGZsq{}\PYGZbs{}n[Cycle \PYGZti{}w] Exploring Problem: \PYGZti{}w + \PYGZti{}w\PYGZti{}n\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{n+nv}{I}\PYG{p}{,} \PYG{n+nv}{AN}\PYG{p}{,} \PYG{n+nv}{BN}\PYG{p}{]),}
    \PYG{p}{(}   \PYG{n+nf}{discover\PYGZus{}strategy}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{StrategyName}\PYG{p}{)}
    \PYG{l+s+sAtom}{\PYGZhy{}\PYGZgt{}}  \PYG{n+nf}{format}\PYG{p}{(}\PYG{l+s+sAtom}{\PYGZsq{}\PYGZhy{}\PYGZgt{} Strategy Discovery Processed: \PYGZti{}w\PYGZti{}n\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{n+nv}{StrategyName}\PYG{p}{])}
    \PYG{p}{;}   \PYG{l+s+sAtom}{true}
    \PYG{p}{),}
    \PYG{n+nv}{NextI} \PYG{o}{is} \PYG{n+nv}{I} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,}
    \PYG{n+nf}{explore\PYGZus{}addition\PYGZus{}loop}\PYG{p}{(}\PYG{n+nv}{NextI}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} Problem Generation (Heuristic)}
\PYG{n+nf}{generate\PYGZus{}addition\PYGZus{}problem}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{random\PYGZus{}between}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{n+nv}{A}\PYG{p}{),}
    \PYG{p}{(}   \PYG{n+nf}{random}\PYG{p}{(}\PYG{n+nv}{R}\PYG{p}{),} \PYG{n+nv}{R} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.3} \PYG{c+c1}{\PYGZpc{} 30\PYGZpc{} chance}
    \PYG{l+s+sAtom}{\PYGZhy{}\PYGZgt{}}  \PYG{n+nv}{B} \PYG{o}{=} \PYG{n+nv}{A}
    \PYG{p}{;}   \PYG{n+nf}{random\PYGZus{}between}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{15}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{)}
    \PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} =================================================================}
\PYG{c+c1}{\PYGZpc{} Part 2: The Unified Solver (Strategy Hierarchy)}
\PYG{c+c1}{\PYGZpc{} =================================================================}

\PYG{c+c1}{\PYGZpc{}!      solve(+A, +B, \PYGZhy{}Result, \PYGZhy{}Trace) is semidet.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       Solves `A + B` using a strategy hierarchy.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       It first attempts to use a highly efficient, learned strategy by}
\PYG{c+c1}{\PYGZpc{}       querying `run\PYGZus{}learned\PYGZus{}strategy/5`. If no applicable learned strategy}
\PYG{c+c1}{\PYGZpc{}       is found, it falls back to the foundational, inefficient counting}
\PYG{c+c1}{\PYGZpc{}       strategy (`solve\PYGZus{}foundationally/4`).}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       @param A The first addend.}
\PYG{c+c1}{\PYGZpc{}       @param B The second addend.}
\PYG{c+c1}{\PYGZpc{}       @param Result The numerical result.}
\PYG{c+c1}{\PYGZpc{}       @param Trace The execution trace produced by the winning strategy.}
\PYG{n+nf}{solve}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{Result}\PYG{p}{,} \PYG{n+nv}{Trace}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{p}{(}   \PYG{n+nf}{run\PYGZus{}learned\PYGZus{}strategy}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{Result}\PYG{p}{,} \PYG{k}{\PYGZus{}}\PYG{n+nv}{StrategyName}\PYG{p}{,} \PYG{n+nv}{Trace}\PYG{p}{)}
    \PYG{l+s+sAtom}{\PYGZhy{}\PYGZgt{}}  \PYG{l+s+sAtom}{true}
    \PYG{p}{;}
        \PYG{n+nf}{solve\PYGZus{}foundationally}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{Result}\PYG{p}{,} \PYG{n+nv}{Trace}\PYG{p}{)}
    \PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} =================================================================}
\PYG{c+c1}{\PYGZpc{} Part 3: Strategy Discovery (The Core Learner)}
\PYG{c+c1}{\PYGZpc{} =================================================================}

\PYG{c+c1}{\PYGZpc{} discover\PYGZus{}strategy(+A, +B, \PYGZhy{}StrategyName)}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{} The core of the learning process. It solves a problem, then analyzes the}
\PYG{c+c1}{\PYGZpc{} trace for patterns that suggest a more efficient strategy could be created.}
\PYG{n+nf}{discover\PYGZus{}strategy}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{StrategyName}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{solve}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{Result}\PYG{p}{,} \PYG{n+nv}{Trace}\PYG{p}{),}
    \PYG{n+nf}{count\PYGZus{}trace\PYGZus{}steps}\PYG{p}{(}\PYG{n+nv}{Trace}\PYG{p}{,} \PYG{n+nv}{TraceLength}\PYG{p}{),}
    \PYG{n+nf}{format}\PYG{p}{(}\PYG{l+s+sAtom}{\PYGZsq{}  Solution found via [\PYGZti{}w]: \PYGZti{}w. Steps: \PYGZti{}w\PYGZti{}n\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{n+nv}{Trace}\PYG{p}{.}\PYG{l+s+sAtom}{strategy}\PYG{p}{,} \PYG{n+nv}{Result}\PYG{p}{,} \PYG{n+nv}{TraceLength}\PYG{p}{]),}
    \PYG{p}{(}   \PYG{n+nf}{detect\PYGZus{}cob\PYGZus{}pattern}\PYG{p}{(}\PYG{n+nv}{Trace}\PYG{p}{,} \PYG{k}{\PYGZus{}}\PYG{p}{),} \PYG{n+nv}{StrategyName} \PYG{o}{=} \PYG{l+s+sAtom}{cob}\PYG{p}{,}
        \PYG{n+nf}{construct\PYGZus{}and\PYGZus{}validate\PYGZus{}cob}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{)}
    \PYG{p}{;}   \PYG{n+nf}{detect\PYGZus{}rmb\PYGZus{}pattern}\PYG{p}{(}\PYG{n+nv}{Trace}\PYG{p}{,} \PYG{n+nv}{RMB\PYGZus{}Data}\PYG{p}{),} \PYG{n+nv}{StrategyName} \PYG{o}{=} \PYG{l+s+sAtom}{rmb}\PYG{p}{,}
        \PYG{n+nf}{construct\PYGZus{}and\PYGZus{}validate\PYGZus{}rmb}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{RMB\PYGZus{}Data}\PYG{p}{)}
    \PYG{p}{;}   \PYG{n+nf}{detect\PYGZus{}doubles\PYGZus{}pattern}\PYG{p}{(}\PYG{n+nv}{Trace}\PYG{p}{,} \PYG{k}{\PYGZus{}}\PYG{p}{),} \PYG{n+nv}{StrategyName} \PYG{o}{=} \PYG{l+s+sAtom}{doubles}\PYG{p}{,}
        \PYG{n+nf}{construct\PYGZus{}and\PYGZus{}validate\PYGZus{}doubles}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{)}
    \PYG{p}{;}   \PYG{l+s+sAtom}{fail}
    \PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} \PYGZhy{}\PYGZhy{}\PYGZhy{} 3.1 Foundational Ability: Counting \PYGZhy{}\PYGZhy{}\PYGZhy{}}

\PYG{n+nf}{successor}\PYG{p}{(}\PYG{n+nv}{X}\PYG{p}{,} \PYG{n+nv}{Y}\PYG{p}{)} \PYG{p}{:\PYGZhy{}} \PYG{n+nf}{proves}\PYG{p}{([]} \PYG{l+s+sAtom}{=\PYGZgt{}} \PYG{p}{[}\PYG{n+nf}{o}\PYG{p}{(}\PYG{n+nf}{plus}\PYG{p}{(}\PYG{n+nv}{X}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nv}{Y}\PYG{p}{))]).}

\PYG{c+c1}{\PYGZpc{} solve\PYGZus{}foundationally(+A, +B, \PYGZhy{}Result, \PYGZhy{}Trace)}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{} The most basic, \PYGZdq{}unfolded\PYGZdq{} strategy. It solves addition by counting on}
\PYG{c+c1}{\PYGZpc{} from A, B times. This is deliberately inefficient to provide rich traces}
\PYG{c+c1}{\PYGZpc{} for the reflective process to analyze.}
\PYG{n+nf}{solve\PYGZus{}foundationally}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{Result}\PYG{p}{,} \PYG{n+nv}{Trace}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{obj\PYGZus{}coll}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{),} \PYG{n+nf}{obj\PYGZus{}coll}\PYG{p}{(}\PYG{n+nv}{B}\PYG{p}{),}
    \PYG{n+nf}{integer}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{),} \PYG{n+nf}{integer}\PYG{p}{(}\PYG{n+nv}{B}\PYG{p}{),} \PYG{n+nv}{B} \PYG{o}{\PYGZgt{}=} \PYG{l+m+mi}{0}\PYG{p}{,}
    \PYG{n+nf}{count\PYGZus{}loop}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{Result}\PYG{p}{,} \PYG{n+nv}{Steps}\PYG{p}{),}
    \PYG{n+nv}{Trace} \PYG{o}{=} \PYG{l+s+sAtom}{trace}\PYG{p}{\PYGZob{}}\PYG{l+s+sAtom}{a\PYGZus{}start:}\PYG{n+nv}{A}\PYG{p}{,} \PYG{l+s+sAtom}{b\PYGZus{}start:}\PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nn}{strategy}\PYG{p}{:}\PYG{l+s+sAtom}{counting}\PYG{p}{,} \PYG{n+nn}{steps}\PYG{p}{:}\PYG{n+nv}{Steps}\PYG{p}{\PYGZcb{}.}

\PYG{n+nf}{count\PYGZus{}loop}\PYG{p}{(}\PYG{n+nv}{CurrentA}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nv}{CurrentA}\PYG{p}{,} \PYG{p}{[])} \PYG{p}{:\PYGZhy{}} \PYG{p}{!.}
\PYG{n+nf}{count\PYGZus{}loop}\PYG{p}{(}\PYG{n+nv}{CurrentA}\PYG{p}{,} \PYG{n+nv}{CurrentB}\PYG{p}{,} \PYG{n+nv}{Result}\PYG{p}{,} \PYG{p}{[}\PYG{n+nf}{step}\PYG{p}{(}\PYG{n+nv}{CurrentA}\PYG{p}{,} \PYG{n+nv}{NextA}\PYG{p}{)|}\PYG{n+nv}{Steps}\PYG{p}{])} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nv}{CurrentB} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{,}
    \PYG{n+nv}{NextB} \PYG{o}{is} \PYG{n+nv}{CurrentB} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,}
    \PYG{n+nf}{successor}\PYG{p}{(}\PYG{n+nv}{CurrentA}\PYG{p}{,} \PYG{n+nv}{NextA}\PYG{p}{),}
    \PYG{n+nf}{count\PYGZus{}loop}\PYG{p}{(}\PYG{n+nv}{NextA}\PYG{p}{,} \PYG{n+nv}{NextB}\PYG{p}{,} \PYG{n+nv}{Result}\PYG{p}{,} \PYG{n+nv}{Steps}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} \PYGZhy{}\PYGZhy{}\PYGZhy{} 3.2 Trace Analysis Helpers \PYGZhy{}\PYGZhy{}\PYGZhy{}}

\PYG{n+nf}{count\PYGZus{}trace\PYGZus{}steps}\PYG{p}{(}\PYG{n+nv}{Trace}\PYG{p}{,} \PYG{n+nv}{Count}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{p}{(}   \PYG{n+nf}{member}\PYG{p}{(}\PYG{n+nv}{Trace}\PYG{p}{.}\PYG{l+s+sAtom}{strategy}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+sAtom}{counting}\PYG{p}{,} \PYG{l+s+sAtom}{doubles}\PYG{p}{,} \PYG{n+nf}{rmb}\PYG{p}{(}\PYG{k}{\PYGZus{}}\PYG{p}{)])}
    \PYG{l+s+sAtom}{\PYGZhy{}\PYGZgt{}}  \PYG{n+nf}{length}\PYG{p}{(}\PYG{n+nv}{Trace}\PYG{p}{.}\PYG{l+s+sAtom}{steps}\PYG{p}{,} \PYG{n+nv}{Count}\PYG{p}{)}
    \PYG{p}{;}   \PYG{n+nv}{Trace}\PYG{p}{.}\PYG{l+s+sAtom}{strategy} \PYG{o}{=} \PYG{l+s+sAtom}{cob}
    \PYG{l+s+sAtom}{\PYGZhy{}\PYGZgt{}}
        \PYG{p}{(} \PYG{n+nf}{member}\PYG{p}{(}\PYG{n+nf}{inner\PYGZus{}trace}\PYG{p}{(}\PYG{n+nv}{InnerTrace}\PYG{p}{),} \PYG{n+nv}{Trace}\PYG{p}{.}\PYG{l+s+sAtom}{steps}\PYG{p}{)}
          \PYG{l+s+sAtom}{\PYGZhy{}\PYGZgt{}} \PYG{n+nf}{count\PYGZus{}trace\PYGZus{}steps}\PYG{p}{(}\PYG{n+nv}{InnerTrace}\PYG{p}{,} \PYG{n+nv}{Count}\PYG{p}{)}
          \PYG{p}{;} \PYG{n+nv}{Count} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{p}{)}
    \PYG{p}{;}   \PYG{n+nv}{Count} \PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{p}{).}

\PYG{n+nf}{get\PYGZus{}calculation\PYGZus{}trace}\PYG{p}{(}\PYG{n+nv}{T}\PYG{p}{,} \PYG{n+nv}{T}\PYG{p}{)} \PYG{p}{:\PYGZhy{}} \PYG{n+nf}{member}\PYG{p}{(}\PYG{n+nv}{T}\PYG{p}{.}\PYG{l+s+sAtom}{strategy}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+sAtom}{counting}\PYG{p}{,} \PYG{n+nf}{rmb}\PYG{p}{(}\PYG{k}{\PYGZus{}}\PYG{p}{),} \PYG{l+s+sAtom}{doubles}\PYG{p}{]).}
\PYG{n+nf}{get\PYGZus{}calculation\PYGZus{}trace}\PYG{p}{(}\PYG{n+nv}{T}\PYG{p}{,} \PYG{n+nv}{CT}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nv}{T}\PYG{p}{.}\PYG{l+s+sAtom}{strategy} \PYG{o}{=} \PYG{l+s+sAtom}{cob}\PYG{p}{,}
    \PYG{n+nf}{member}\PYG{p}{(}\PYG{n+nf}{inner\PYGZus{}trace}\PYG{p}{(}\PYG{n+nv}{InnerT}\PYG{p}{),} \PYG{n+nv}{T}\PYG{p}{.}\PYG{l+s+sAtom}{steps}\PYG{p}{),}
    \PYG{n+nf}{get\PYGZus{}calculation\PYGZus{}trace}\PYG{p}{(}\PYG{n+nv}{InnerT}\PYG{p}{,} \PYG{n+nv}{CT}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} =================================================================}
\PYG{c+c1}{\PYGZpc{} Part 4: Pattern Detection \PYGZam{} Construction}
\PYG{c+c1}{\PYGZpc{} =================================================================}

\PYG{c+c1}{\PYGZpc{} Detects if an inefficient counting strategy was used where commutativity (A+B = B+A) would have been more efficient.}
\PYG{n+nf}{detect\PYGZus{}cob\PYGZus{}pattern}\PYG{p}{(}\PYG{n+nv}{Trace}\PYG{p}{,} \PYG{l+s+sAtom}{cob\PYGZus{}data}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nv}{Trace}\PYG{p}{.}\PYG{l+s+sAtom}{strategy} \PYG{o}{=} \PYG{l+s+sAtom}{counting}\PYG{p}{,}
    \PYG{n+nv}{A} \PYG{o}{=} \PYG{n+nv}{Trace}\PYG{p}{.}\PYG{l+s+sAtom}{a\PYGZus{}start}\PYG{p}{,} \PYG{n+nv}{B} \PYG{o}{=} \PYG{n+nv}{Trace}\PYG{p}{.}\PYG{l+s+sAtom}{b\PYGZus{}start}\PYG{p}{,}
    \PYG{n+nf}{integer}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{),} \PYG{n+nf}{integer}\PYG{p}{(}\PYG{n+nv}{B}\PYG{p}{),}
    \PYG{n+nv}{A} \PYG{o}{\PYGZlt{}} \PYG{n+nv}{B}\PYG{p}{.}

\PYG{c+c1}{\PYGZpc{} Constructs and validates a new \PYGZdq{}Counting On Bigger\PYGZdq{} (COB) strategy clause.}
\PYG{n+nf}{construct\PYGZus{}and\PYGZus{}validate\PYGZus{}cob}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nv}{StrategyName} \PYG{o}{=} \PYG{l+s+sAtom}{cob}\PYG{p}{,}
    \PYG{n+nv}{StrategyHead} \PYG{o}{=} \PYG{n+nf}{run\PYGZus{}learned\PYGZus{}strategy}\PYG{p}{(}\PYG{n+nv}{A\PYGZus{}in}\PYG{p}{,} \PYG{n+nv}{B\PYGZus{}in}\PYG{p}{,} \PYG{n+nv}{Result}\PYG{p}{,} \PYG{n+nv}{StrategyName}\PYG{p}{,} \PYG{n+nv}{Trace}\PYG{p}{),}
    \PYG{n+nv}{StrategyBody} \PYG{o}{=} \PYG{p}{(}
        \PYG{n+nf}{integer}\PYG{p}{(}\PYG{n+nv}{A\PYGZus{}in}\PYG{p}{),} \PYG{n+nf}{integer}\PYG{p}{(}\PYG{n+nv}{B\PYGZus{}in}\PYG{p}{),}
        \PYG{p}{(}\PYG{n+nv}{A\PYGZus{}in} \PYG{o}{\PYGZgt{}=} \PYG{n+nv}{B\PYGZus{}in} \PYG{l+s+sAtom}{\PYGZhy{}\PYGZgt{}} \PYG{n+nv}{Start} \PYG{o}{=} \PYG{n+nv}{A\PYGZus{}in}\PYG{p}{,} \PYG{n+nv}{Count} \PYG{o}{=} \PYG{n+nv}{B\PYGZus{}in}\PYG{p}{,} \PYG{n+nv}{Swap} \PYG{o}{=} \PYG{l+s+sAtom}{no\PYGZus{}swap} \PYG{p}{;} \PYG{n+nv}{Start} \PYG{o}{=} \PYG{n+nv}{B\PYGZus{}in}\PYG{p}{,} \PYG{n+nv}{Count} \PYG{o}{=} \PYG{n+nv}{A\PYGZus{}in}\PYG{p}{,} \PYG{n+nv}{Swap} \PYG{o}{=} \PYG{n+nf}{swapped}\PYG{p}{(}\PYG{n+nv}{B\PYGZus{}in}\PYG{p}{,} \PYG{n+nv}{A\PYGZus{}in}\PYG{p}{)),}
        \PYG{p}{(}   \PYG{n+nv}{Swap} \PYG{o}{=} \PYG{n+nf}{swapped}\PYG{p}{(}\PYG{k}{\PYGZus{}}\PYG{p}{,} \PYG{k}{\PYGZus{}}\PYG{p}{)} \PYG{l+s+sAtom}{\PYGZhy{}\PYGZgt{}}
            \PYG{p}{(}\PYG{n+nf}{proves}\PYG{p}{([}\PYG{n+nf}{n}\PYG{p}{(}\PYG{n+nf}{plus}\PYG{p}{(}\PYG{n+nv}{A\PYGZus{}in}\PYG{p}{,} \PYG{n+nv}{B\PYGZus{}in}\PYG{p}{,} \PYG{n+nv}{R\PYGZus{}temp}\PYG{p}{))]} \PYG{l+s+sAtom}{=\PYGZgt{}} \PYG{p}{[}\PYG{n+nf}{n}\PYG{p}{(}\PYG{n+nf}{plus}\PYG{p}{(}\PYG{n+nv}{B\PYGZus{}in}\PYG{p}{,} \PYG{n+nv}{A\PYGZus{}in}\PYG{p}{,} \PYG{n+nv}{R\PYGZus{}temp}\PYG{p}{))])} \PYG{l+s+sAtom}{\PYGZhy{}\PYGZgt{}} \PYG{l+s+sAtom}{true} \PYG{p}{;} \PYG{l+s+sAtom}{fail}\PYG{p}{)}
            \PYG{p}{;} \PYG{l+s+sAtom}{true}
        \PYG{p}{),}
        \PYG{n+nf}{solve\PYGZus{}foundationally}\PYG{p}{(}\PYG{n+nv}{Start}\PYG{p}{,} \PYG{n+nv}{Count}\PYG{p}{,} \PYG{n+nv}{Result}\PYG{p}{,} \PYG{n+nv}{InnerTrace}\PYG{p}{),}
        \PYG{n+nv}{Trace} \PYG{o}{=} \PYG{l+s+sAtom}{trace}\PYG{p}{\PYGZob{}}\PYG{l+s+sAtom}{a\PYGZus{}start:}\PYG{n+nv}{A\PYGZus{}in}\PYG{p}{,} \PYG{l+s+sAtom}{b\PYGZus{}start:}\PYG{n+nv}{B\PYGZus{}in}\PYG{p}{,} \PYG{n+nn}{strategy}\PYG{p}{:}\PYG{n+nv}{StrategyName}\PYG{p}{,} \PYG{n+nn}{steps}\PYG{p}{:[}\PYG{n+nv}{Swap}\PYG{p}{,} \PYG{n+nf}{inner\PYGZus{}trace}\PYG{p}{(}\PYG{n+nv}{InnerTrace}\PYG{p}{)]\PYGZcb{}}
    \PYG{p}{),}
    \PYG{n+nf}{validate\PYGZus{}and\PYGZus{}assert}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{StrategyHead}\PYG{p}{,} \PYG{n+nv}{StrategyBody}\PYG{p}{).}


\PYG{c+c1}{\PYGZpc{} Detects if the counting trace shows a pattern of \PYGZdq{}making a ten\PYGZdq{}.}
\PYG{n+nf}{detect\PYGZus{}rmb\PYGZus{}pattern}\PYG{p}{(}\PYG{n+nv}{TraceWrapper}\PYG{p}{,} \PYG{l+s+sAtom}{rmb\PYGZus{}data}\PYG{p}{\PYGZob{}}\PYG{n+nn}{k}\PYG{p}{:}\PYG{n+nv}{K}\PYG{p}{,} \PYG{n+nn}{base}\PYG{p}{:}\PYG{n+nv}{Base}\PYG{p}{\PYGZcb{})} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{get\PYGZus{}calculation\PYGZus{}trace}\PYG{p}{(}\PYG{n+nv}{TraceWrapper}\PYG{p}{,} \PYG{n+nv}{Trace}\PYG{p}{),}
    \PYG{n+nv}{Trace}\PYG{p}{.}\PYG{l+s+sAtom}{strategy} \PYG{o}{=} \PYG{l+s+sAtom}{counting}\PYG{p}{,}
    \PYG{n+nv}{Base} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{,}
    \PYG{n+nv}{A} \PYG{o}{=} \PYG{n+nv}{Trace}\PYG{p}{.}\PYG{l+s+sAtom}{a\PYGZus{}start}\PYG{p}{,} \PYG{n+nv}{B} \PYG{o}{=} \PYG{n+nv}{Trace}\PYG{p}{.}\PYG{l+s+sAtom}{b\PYGZus{}start}\PYG{p}{,}
    \PYG{n+nf}{integer}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{),} \PYG{n+nf}{integer}\PYG{p}{(}\PYG{n+nv}{B}\PYG{p}{),}
    \PYG{n+nv}{A} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nv}{A} \PYG{o}{\PYGZlt{}} \PYG{n+nv}{Base}\PYG{p}{,} \PYG{n+nv}{K} \PYG{o}{is} \PYG{n+nv}{Base} \PYG{o}{\PYGZhy{}} \PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B} \PYG{o}{\PYGZgt{}=} \PYG{n+nv}{K}\PYG{p}{,}
    \PYG{n+nf}{nth1}\PYG{p}{(}\PYG{n+nv}{K}\PYG{p}{,} \PYG{n+nv}{Trace}\PYG{p}{.}\PYG{l+s+sAtom}{steps}\PYG{p}{,} \PYG{n+nv}{Step}\PYG{p}{),}
    \PYG{n+nv}{Step} \PYG{o}{=} \PYG{n+nf}{step}\PYG{p}{(}\PYG{k}{\PYGZus{}}\PYG{p}{,} \PYG{n+nv}{Base}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} Constructs and validates a new \PYGZdq{}Rearranging to Make Bases\PYGZdq{} (RMB) strategy.}
\PYG{n+nf}{construct\PYGZus{}and\PYGZus{}validate\PYGZus{}rmb}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{RMB\PYGZus{}Data}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nv}{Base} \PYG{o}{=} \PYG{n+nv}{RMB\PYGZus{}Data}\PYG{p}{.}\PYG{l+s+sAtom}{base}\PYG{p}{,}
    \PYG{n+nv}{StrategyName} \PYG{o}{=} \PYG{n+nf}{rmb}\PYG{p}{(}\PYG{n+nv}{Base}\PYG{p}{),}
    \PYG{n+nv}{StrategyHead} \PYG{o}{=} \PYG{n+nf}{run\PYGZus{}learned\PYGZus{}strategy}\PYG{p}{(}\PYG{n+nv}{A\PYGZus{}in}\PYG{p}{,} \PYG{n+nv}{B\PYGZus{}in}\PYG{p}{,} \PYG{n+nv}{Result}\PYG{p}{,} \PYG{n+nv}{StrategyName}\PYG{p}{,} \PYG{n+nv}{Trace}\PYG{p}{),}
    \PYG{n+nv}{StrategyBody} \PYG{o}{=} \PYG{p}{(}
        \PYG{n+nf}{integer}\PYG{p}{(}\PYG{n+nv}{A\PYGZus{}in}\PYG{p}{),} \PYG{n+nf}{integer}\PYG{p}{(}\PYG{n+nv}{B\PYGZus{}in}\PYG{p}{),}
        \PYG{n+nv}{A\PYGZus{}in} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nv}{A\PYGZus{}in} \PYG{o}{\PYGZlt{}} \PYG{n+nv}{Base}\PYG{p}{,} \PYG{n+nv}{K\PYGZus{}runtime} \PYG{o}{is} \PYG{n+nv}{Base} \PYG{o}{\PYGZhy{}} \PYG{n+nv}{A\PYGZus{}in}\PYG{p}{,} \PYG{n+nv}{B\PYGZus{}in} \PYG{o}{\PYGZgt{}=} \PYG{n+nv}{K\PYGZus{}runtime}\PYG{p}{,}
        \PYG{n+nv}{B\PYGZus{}new\PYGZus{}runtime} \PYG{o}{is} \PYG{n+nv}{B\PYGZus{}in} \PYG{o}{\PYGZhy{}} \PYG{n+nv}{K\PYGZus{}runtime}\PYG{p}{,}
        \PYG{n+nv}{Result} \PYG{o}{is} \PYG{n+nv}{Base} \PYG{o}{+} \PYG{n+nv}{B\PYGZus{}new\PYGZus{}runtime}\PYG{p}{,}
        \PYG{n+nv}{Trace} \PYG{o}{=} \PYG{l+s+sAtom}{trace}\PYG{p}{\PYGZob{}}\PYG{l+s+sAtom}{a\PYGZus{}start:}\PYG{n+nv}{A\PYGZus{}in}\PYG{p}{,} \PYG{l+s+sAtom}{b\PYGZus{}start:}\PYG{n+nv}{B\PYGZus{}in}\PYG{p}{,} \PYG{n+nn}{strategy}\PYG{p}{:}\PYG{n+nv}{StrategyName}\PYG{p}{,} \PYG{n+nn}{steps}\PYG{p}{:[}\PYG{n+nf}{step}\PYG{p}{(}\PYG{n+nv}{A\PYGZus{}in}\PYG{p}{,} \PYG{n+nv}{Base}\PYG{p}{),} \PYG{n+nf}{step}\PYG{p}{(}\PYG{n+nv}{Base}\PYG{p}{,} \PYG{n+nv}{Result}\PYG{p}{)]\PYGZcb{}}
    \PYG{p}{),}
    \PYG{n+nf}{validate\PYGZus{}and\PYGZus{}assert}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{StrategyHead}\PYG{p}{,} \PYG{n+nv}{StrategyBody}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} Detects if a problem was a \PYGZdq{}doubles\PYGZdq{} fact that was solved less efficiently.}
\PYG{n+nf}{detect\PYGZus{}doubles\PYGZus{}pattern}\PYG{p}{(}\PYG{n+nv}{TraceWrapper}\PYG{p}{,} \PYG{l+s+sAtom}{doubles\PYGZus{}data}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{get\PYGZus{}calculation\PYGZus{}trace}\PYG{p}{(}\PYG{n+nv}{TraceWrapper}\PYG{p}{,} \PYG{n+nv}{Trace}\PYG{p}{),}
    \PYG{n+nf}{member}\PYG{p}{(}\PYG{n+nv}{Trace}\PYG{p}{.}\PYG{l+s+sAtom}{strategy}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+sAtom}{counting}\PYG{p}{,} \PYG{n+nf}{rmb}\PYG{p}{(}\PYG{k}{\PYGZus{}}\PYG{p}{)]),}
    \PYG{n+nv}{A} \PYG{o}{=} \PYG{n+nv}{Trace}\PYG{p}{.}\PYG{l+s+sAtom}{a\PYGZus{}start}\PYG{p}{,} \PYG{n+nv}{B} \PYG{o}{=} \PYG{n+nv}{Trace}\PYG{p}{.}\PYG{l+s+sAtom}{b\PYGZus{}start}\PYG{p}{,}
    \PYG{n+nv}{A} \PYG{o}{==} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nf}{integer}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} Constructs and validates a new \PYGZdq{}Doubles\PYGZdq{} strategy (rote knowledge).}
\PYG{n+nf}{construct\PYGZus{}and\PYGZus{}validate\PYGZus{}doubles}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nv}{StrategyName} \PYG{o}{=} \PYG{l+s+sAtom}{doubles}\PYG{p}{,}
    \PYG{n+nv}{StrategyHead} \PYG{o}{=} \PYG{n+nf}{run\PYGZus{}learned\PYGZus{}strategy}\PYG{p}{(}\PYG{n+nv}{A\PYGZus{}in}\PYG{p}{,} \PYG{n+nv}{B\PYGZus{}in}\PYG{p}{,} \PYG{n+nv}{Result}\PYG{p}{,} \PYG{n+nv}{StrategyName}\PYG{p}{,} \PYG{n+nv}{Trace}\PYG{p}{),}
    \PYG{n+nv}{StrategyBody} \PYG{o}{=} \PYG{p}{(}
        \PYG{n+nf}{integer}\PYG{p}{(}\PYG{n+nv}{A\PYGZus{}in}\PYG{p}{),} \PYG{n+nv}{A\PYGZus{}in} \PYG{o}{==} \PYG{n+nv}{B\PYGZus{}in}\PYG{p}{,}
        \PYG{n+nv}{Result} \PYG{o}{is} \PYG{n+nv}{A\PYGZus{}in} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{,}
        \PYG{n+nv}{Trace} \PYG{o}{=} \PYG{l+s+sAtom}{trace}\PYG{p}{\PYGZob{}}\PYG{l+s+sAtom}{a\PYGZus{}start:}\PYG{n+nv}{A\PYGZus{}in}\PYG{p}{,} \PYG{l+s+sAtom}{b\PYGZus{}start:}\PYG{n+nv}{B\PYGZus{}in}\PYG{p}{,} \PYG{n+nn}{strategy}\PYG{p}{:}\PYG{n+nv}{StrategyName}\PYG{p}{,} \PYG{n+nn}{steps}\PYG{p}{:[}\PYG{n+nf}{rote}\PYG{p}{(}\PYG{n+nv}{Result}\PYG{p}{)]\PYGZcb{}}
    \PYG{p}{),}
    \PYG{n+nf}{validate\PYGZus{}and\PYGZus{}assert}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{StrategyHead}\PYG{p}{,} \PYG{n+nv}{StrategyBody}\PYG{p}{).}


\PYG{c+c1}{\PYGZpc{} \PYGZhy{}\PYGZhy{}\PYGZhy{} Validation Helper \PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZpc{} Ensures a newly constructed strategy is sound before asserting it.}
\PYG{n+nf}{validate\PYGZus{}and\PYGZus{}assert}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{StrategyHead}\PYG{p}{,} \PYG{n+nv}{StrategyBody}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{copy\PYGZus{}term}\PYG{p}{((}\PYG{n+nv}{StrategyHead}\PYG{p}{,} \PYG{n+nv}{StrategyBody}\PYG{p}{),} \PYG{p}{(}\PYG{n+nv}{ValidationHead}\PYG{p}{,} \PYG{n+nv}{ValidationBody}\PYG{p}{)),}
    \PYG{n+nf}{arg}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nv}{ValidationHead}\PYG{p}{,} \PYG{n+nv}{A}\PYG{p}{),}
    \PYG{n+nf}{arg}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n+nv}{ValidationHead}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{),}
    \PYG{n+nf}{arg}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n+nv}{ValidationHead}\PYG{p}{,} \PYG{n+nv}{CalculatedResult}\PYG{p}{),}
    \PYG{n+nf}{arg}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n+nv}{ValidationHead}\PYG{p}{,} \PYG{n+nv}{StrategyName}\PYG{p}{),}

    \PYG{p}{(}   \PYG{n+nf}{call}\PYG{p}{(}\PYG{n+nv}{ValidationBody}\PYG{p}{),}
        \PYG{n+nf}{proves}\PYG{p}{([]} \PYG{l+s+sAtom}{=\PYGZgt{}} \PYG{p}{[}\PYG{n+nf}{o}\PYG{p}{(}\PYG{n+nf}{plus}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{CalculatedResult}\PYG{p}{))])}
    \PYG{l+s+sAtom}{\PYGZhy{}\PYGZgt{}}
        \PYG{p}{(}   \PYG{n+nf}{clause}\PYG{p}{(}\PYG{n+nf}{run\PYGZus{}learned\PYGZus{}strategy}\PYG{p}{(}\PYG{k}{\PYGZus{}}\PYG{p}{,} \PYG{k}{\PYGZus{}}\PYG{p}{,} \PYG{k}{\PYGZus{}}\PYG{p}{,} \PYG{n+nv}{StrategyName}\PYG{p}{,} \PYG{k}{\PYGZus{}}\PYG{p}{),} \PYG{k}{\PYGZus{}}\PYG{p}{)}
        \PYG{l+s+sAtom}{\PYGZhy{}\PYGZgt{}}  \PYG{n+nf}{format}\PYG{p}{(}\PYG{l+s+sAtom}{\PYGZsq{}  (Strategy \PYGZti{}w already known)\PYGZti{}n\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{n+nv}{StrategyName}\PYG{p}{])}
        \PYG{p}{;}   \PYG{n+nf}{assertz}\PYG{p}{((}\PYG{n+nv}{StrategyHead} \PYG{p}{:\PYGZhy{}} \PYG{n+nv}{StrategyBody}\PYG{p}{)),}
            \PYG{n+nf}{format}\PYG{p}{(}\PYG{l+s+sAtom}{\PYGZsq{}  \PYGZhy{}\PYGZgt{} New Strategy Asserted: \PYGZti{}w\PYGZti{}n\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{n+nv}{StrategyName}\PYG{p}{])}
        \PYG{p}{)}
    \PYG{p}{;}   \PYG{n+nf}{writeln}\PYG{p}{(}\PYG{l+s+sAtom}{\PYGZsq{}ERROR: Strategy validation failed. Not asserted.\PYGZsq{}}\PYG{p}{)}
    \PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} =================================================================}
\PYG{c+c1}{\PYGZpc{} Part 5: Normative Critique (Placeholder)}
\PYG{c+c1}{\PYGZpc{} =================================================================}

\PYG{c+c1}{\PYGZpc{}!      critique\PYGZus{}and\PYGZus{}bootstrap(+Goal:term) is det.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       Placeholder for a future capability where the system can analyze}
\PYG{c+c1}{\PYGZpc{}       a given normative rule (e.g., a subtraction problem that challenges}
\PYG{c+c1}{\PYGZpc{}       its current knowledge) and potentially learn from it.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       @param Goal The goal representing the normative rule to critique.}
\PYG{n+nf}{critique\PYGZus{}and\PYGZus{}bootstrap}\PYG{p}{(}\PYG{k}{\PYGZus{}}\PYG{p}{)} \PYG{p}{:\PYGZhy{}} \PYG{n+nf}{writeln}\PYG{p}{(}\PYG{l+s+sAtom}{\PYGZsq{}Normative Critique Placeholder.\PYGZsq{}}\PYG{p}{).}
\end{MintedVerbatim}
