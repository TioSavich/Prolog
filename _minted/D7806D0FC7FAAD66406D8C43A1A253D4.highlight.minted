\begin{MintedVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/** \PYGZlt{}module\PYGZgt{} Student Multiplication Strategy: Commutative Reasoning (Repeated Addition)}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * This module implements a multiplication strategy based on repeated addition,}
\PYG{c+cm}{ * modeled as a finite state machine. The name \PYGZdq{}Commutative Reasoning\PYGZdq{} implies}
\PYG{c+cm}{ * that a student understands that `A * B` is equivalent to `B * A` and can}
\PYG{c+cm}{ * choose the more efficient path. However, this model directly implements}
\PYG{c+cm}{ * `A * B` as adding `B` to itself `A` times.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * The process is as follows:}
\PYG{c+cm}{ * 1.  Start with a total of 0.}
\PYG{c+cm}{ * 2.  Repeatedly add the number of items (`B`) to the total.}
\PYG{c+cm}{ * 3.  Use a counter, initialized to the number of groups (`A`), to track}
\PYG{c+cm}{ *     how many times to perform the addition.}
\PYG{c+cm}{ * 4.  The process stops when the counter reaches zero. The accumulated total}
\PYG{c+cm}{ *     is the final product.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * The state is represented by the term:}
\PYG{c+cm}{ * `state(Name, Groups, Items, Total, Counter)`}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * The history of execution is captured as a list of steps:}
\PYG{c+cm}{ * `step(Name, Groups, Items, Total, Interpretation)`}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * }
\PYG{c+cm}{ * }
\PYG{c+cm}{ */}
\PYG{p}{:\PYGZhy{}} \PYG{n+nf}{module}\PYG{p}{(}\PYG{l+s+sAtom}{smr\PYGZus{}mult\PYGZus{}commutative\PYGZus{}reasoning}\PYG{p}{,}
          \PYG{p}{[} \PYG{l+s+sAtom}{run\PYGZus{}commutative\PYGZus{}mult}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,}
            \PYG{c+c1}{\PYGZpc{} FSM Engine Interface}
            \PYG{l+s+sAtom}{setup\PYGZus{}strategy}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s+sAtom}{transition}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+s+sAtom}{transition}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,}
            \PYG{l+s+sAtom}{accept\PYGZus{}state}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+sAtom}{final\PYGZus{}interpretation}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+sAtom}{extract\PYGZus{}result\PYGZus{}from\PYGZus{}history}\PYG{o}{/}\PYG{l+m+mi}{2}
          \PYG{p}{]).}

\PYG{p}{:\PYGZhy{}} \PYG{n+nf}{use\PYGZus{}module}\PYG{p}{(}\PYG{n+nf}{library}\PYG{p}{(}\PYG{l+s+sAtom}{lists}\PYG{p}{)).}
\PYG{p}{:\PYGZhy{}} \PYG{n+nf}{use\PYGZus{}module}\PYG{p}{(}\PYG{l+s+sAtom}{fsm\PYGZus{}engine}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+sAtom}{run\PYGZus{}fsm\PYGZus{}with\PYGZus{}base}\PYG{o}{/}\PYG{l+m+mi}{5}\PYG{p}{]).}
\PYG{p}{:\PYGZhy{}} \PYG{n+nf}{use\PYGZus{}module}\PYG{p}{(}\PYG{l+s+sAtom}{grounded\PYGZus{}arithmetic}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+sAtom}{incur\PYGZus{}cost}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{p}{]).}
\PYG{p}{:\PYGZhy{}} \PYG{n+nf}{use\PYGZus{}module}\PYG{p}{(}\PYG{l+s+sAtom}{incompatibility\PYGZus{}semantics}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+sAtom}{s}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+sAtom}{comp\PYGZus{}nec}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+sAtom}{exp\PYGZus{}poss}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{p}{]).}

\PYG{c+c1}{\PYGZpc{}!      run\PYGZus{}commutative\PYGZus{}mult(+A:integer, +B:integer, \PYGZhy{}FinalTotal:integer, \PYGZhy{}History:list) is det.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       Executes the \PYGZsq{}Commutative Reasoning\PYGZsq{} (Repeated Addition) multiplication}
\PYG{c+c1}{\PYGZpc{}       strategy for A * B.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       This predicate initializes and runs a state machine that models the}
\PYG{c+c1}{\PYGZpc{}       process of calculating `A * B` by adding `B` to an accumulator `A` times.}
\PYG{c+c1}{\PYGZpc{}       It traces the entire execution, providing a step\PYGZhy{}by\PYGZhy{}step history of}
\PYG{c+c1}{\PYGZpc{}       the repeated addition.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       @param A The number of groups (effectively, the number of additions).}
\PYG{c+c1}{\PYGZpc{}       @param B The number of items in each group (the number being added).}
\PYG{c+c1}{\PYGZpc{}       @param FinalTotal The resulting product of A * B.}
\PYG{c+c1}{\PYGZpc{}       @param History A list of `step/5` terms that describe the state}
\PYG{c+c1}{\PYGZpc{}       machine\PYGZsq{}s execution path and the interpretation of each step.}

\PYG{n+nf}{run\PYGZus{}commutative\PYGZus{}mult}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{FinalTotal}\PYG{p}{,} \PYG{n+nv}{History}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{incur\PYGZus{}cost}\PYG{p}{(}\PYG{l+s+sAtom}{strategy\PYGZus{}selection}\PYG{p}{),}
    \PYG{n+nf}{setup\PYGZus{}strategy}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{InitialState}\PYG{p}{,} \PYG{n+nv}{Parameters}\PYG{p}{),}
    \PYG{n+nv}{Base} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{,}
    \PYG{n+nf}{run\PYGZus{}fsm\PYGZus{}with\PYGZus{}base}\PYG{p}{(}\PYG{l+s+sAtom}{smr\PYGZus{}mult\PYGZus{}commutative\PYGZus{}reasoning}\PYG{p}{,} \PYG{n+nv}{InitialState}\PYG{p}{,} \PYG{n+nv}{Parameters}\PYG{p}{,} \PYG{n+nv}{Base}\PYG{p}{,} \PYG{n+nv}{History}\PYG{p}{),}
    \PYG{n+nf}{extract\PYGZus{}result\PYGZus{}from\PYGZus{}history}\PYG{p}{(}\PYG{n+nv}{History}\PYG{p}{,} \PYG{n+nv}{FinalTotal}\PYG{p}{).}

\PYG{n+nf}{setup\PYGZus{}strategy}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{InitialState}\PYG{p}{,} \PYG{n+nv}{Parameters}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{c+c1}{\PYGZpc{} Initialize: Groups=A, Items=B, Total=0, Counter=A}
    \PYG{n+nv}{InitialState} \PYG{o}{=} \PYG{n+nf}{state}\PYG{p}{(}\PYG{l+s+sAtom}{q\PYGZus{}init\PYGZus{}calc}\PYG{p}{,} \PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nv}{A}\PYG{p}{),}
    \PYG{n+nv}{Parameters} \PYG{o}{=} \PYG{p}{[}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{],}
    \PYG{n+nf}{s}\PYG{p}{(}\PYG{n+nf}{exp\PYGZus{}poss}\PYG{p}{(}\PYG{l+s+sAtom}{initiating\PYGZus{}commutative\PYGZus{}reasoning\PYGZus{}multiplication}\PYG{p}{)),}
    \PYG{n+nf}{incur\PYGZus{}cost}\PYG{p}{(}\PYG{l+s+sAtom}{inference}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} run/3 is the main recursive loop of the state machine.}
\PYG{c+c1}{\PYGZpc{} FSM Engine transitions}

\PYG{n+nf}{transition}\PYG{p}{(}\PYG{l+s+sAtom}{q\PYGZus{}init\PYGZus{}calc}\PYG{p}{,} \PYG{l+s+sAtom}{q\PYGZus{}loop\PYGZus{}calc}\PYG{p}{,} \PYG{l+s+sAtom}{initialize\PYGZus{}calculation}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{s}\PYG{p}{(}\PYG{n+nf}{comp\PYGZus{}nec}\PYG{p}{(}\PYG{l+s+sAtom}{transitioning\PYGZus{}to\PYGZus{}iterative\PYGZus{}calculation}\PYG{p}{)),} \PYG{n+nf}{incur\PYGZus{}cost}\PYG{p}{(}\PYG{l+s+sAtom}{state\PYGZus{}change}\PYG{p}{).}

\PYG{n+nf}{transition}\PYG{p}{(}\PYG{l+s+sAtom}{q\PYGZus{}loop\PYGZus{}calc}\PYG{p}{,} \PYG{l+s+sAtom}{q\PYGZus{}loop\PYGZus{}calc}\PYG{p}{,} \PYG{l+s+sAtom}{add\PYGZus{}items\PYGZus{}iteration}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{s}\PYG{p}{(}\PYG{n+nf}{exp\PYGZus{}poss}\PYG{p}{(}\PYG{l+s+sAtom}{continuing\PYGZus{}repeated\PYGZus{}addition\PYGZus{}iteration}\PYG{p}{)),} \PYG{n+nf}{incur\PYGZus{}cost}\PYG{p}{(}\PYG{l+s+sAtom}{iteration}\PYG{p}{).}

\PYG{n+nf}{transition}\PYG{p}{(}\PYG{l+s+sAtom}{q\PYGZus{}loop\PYGZus{}calc}\PYG{p}{,} \PYG{l+s+sAtom}{q\PYGZus{}accept}\PYG{p}{,} \PYG{l+s+sAtom}{complete\PYGZus{}multiplication}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{s}\PYG{p}{(}\PYG{n+nf}{comp\PYGZus{}nec}\PYG{p}{(}\PYG{l+s+sAtom}{finalizing\PYGZus{}commutative\PYGZus{}multiplication}\PYG{p}{)),} \PYG{n+nf}{incur\PYGZus{}cost}\PYG{p}{(}\PYG{l+s+sAtom}{completion}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} Complete state transitions}
\PYG{n+nf}{transition}\PYG{p}{(}\PYG{n+nf}{state}\PYG{p}{(}\PYG{l+s+sAtom}{q\PYGZus{}init\PYGZus{}calc}\PYG{p}{,} \PYG{n+nv}{Gs}\PYG{p}{,} \PYG{n+nv}{Items}\PYG{p}{,} \PYG{k}{\PYGZus{}}\PYG{p}{,} \PYG{k}{\PYGZus{}}\PYG{p}{),} \PYG{k}{\PYGZus{}}\PYG{p}{,} \PYG{n+nf}{state}\PYG{p}{(}\PYG{l+s+sAtom}{q\PYGZus{}loop\PYGZus{}calc}\PYG{p}{,} \PYG{n+nv}{Gs}\PYG{p}{,} \PYG{n+nv}{Items}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nv}{Gs}\PYG{p}{),}
           \PYG{l+s+sAtom}{\PYGZsq{}Initializing iterative calculation.\PYGZsq{}}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{s}\PYG{p}{(}\PYG{n+nf}{exp\PYGZus{}poss}\PYG{p}{(}\PYG{l+s+sAtom}{initializing\PYGZus{}repeated\PYGZus{}addition\PYGZus{}phase}\PYG{p}{)),} \PYG{n+nf}{incur\PYGZus{}cost}\PYG{p}{(}\PYG{l+s+sAtom}{initialization}\PYG{p}{).}

\PYG{n+nf}{transition}\PYG{p}{(}\PYG{n+nf}{state}\PYG{p}{(}\PYG{l+s+sAtom}{q\PYGZus{}loop\PYGZus{}calc}\PYG{p}{,} \PYG{n+nv}{Gs}\PYG{p}{,} \PYG{n+nv}{Items}\PYG{p}{,} \PYG{n+nv}{Total}\PYG{p}{,} \PYG{n+nv}{Counter}\PYG{p}{),} \PYG{k}{\PYGZus{}}\PYG{p}{,} \PYG{n+nf}{state}\PYG{p}{(}\PYG{l+s+sAtom}{q\PYGZus{}loop\PYGZus{}calc}\PYG{p}{,} \PYG{n+nv}{Gs}\PYG{p}{,} \PYG{n+nv}{Items}\PYG{p}{,} \PYG{n+nv}{NewTotal}\PYG{p}{,} \PYG{n+nv}{NewCounter}\PYG{p}{),} \PYG{n+nv}{Interp}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nv}{Counter} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{,}
    \PYG{n+nf}{s}\PYG{p}{(}\PYG{n+nf}{comp\PYGZus{}nec}\PYG{p}{(}\PYG{l+s+sAtom}{applying\PYGZus{}embodied\PYGZus{}repeated\PYGZus{}addition}\PYG{p}{)),}
    \PYG{n+nv}{NewTotal} \PYG{o}{is} \PYG{n+nv}{Total} \PYG{o}{+} \PYG{n+nv}{Items}\PYG{p}{,} \PYG{n+nv}{NewCounter} \PYG{o}{is} \PYG{n+nv}{Counter} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,}
    \PYG{n+nf}{format}\PYG{p}{(}\PYG{n+nf}{atom}\PYG{p}{(}\PYG{n+nv}{Interp}\PYG{p}{),} \PYG{l+s+sAtom}{\PYGZsq{}Iterate: Added \PYGZti{}w. Total = \PYGZti{}w.\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{n+nv}{Items}\PYG{p}{,} \PYG{n+nv}{NewTotal}\PYG{p}{]),}
    \PYG{n+nf}{incur\PYGZus{}cost}\PYG{p}{(}\PYG{l+s+sAtom}{addition\PYGZus{}iteration}\PYG{p}{).}

\PYG{n+nf}{transition}\PYG{p}{(}\PYG{n+nf}{state}\PYG{p}{(}\PYG{l+s+sAtom}{q\PYGZus{}loop\PYGZus{}calc}\PYG{p}{,} \PYG{n+nv}{Gs}\PYG{p}{,} \PYG{n+nv}{Items}\PYG{p}{,} \PYG{n+nv}{Total}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{),} \PYG{k}{\PYGZus{}}\PYG{p}{,} \PYG{n+nf}{state}\PYG{p}{(}\PYG{l+s+sAtom}{q\PYGZus{}accept}\PYG{p}{,} \PYG{n+nv}{Gs}\PYG{p}{,} \PYG{n+nv}{Items}\PYG{p}{,} \PYG{n+nv}{Total}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{),}
           \PYG{l+s+sAtom}{\PYGZsq{}Counter reached zero. Calculation complete.\PYGZsq{}}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{s}\PYG{p}{(}\PYG{n+nf}{exp\PYGZus{}poss}\PYG{p}{(}\PYG{l+s+sAtom}{completing\PYGZus{}repeated\PYGZus{}addition\PYGZus{}strategy}\PYG{p}{)),} \PYG{n+nf}{incur\PYGZus{}cost}\PYG{p}{(}\PYG{l+s+sAtom}{strategy\PYGZus{}completion}\PYG{p}{).}

\PYG{n+nf}{accept\PYGZus{}state}\PYG{p}{(}\PYG{n+nf}{state}\PYG{p}{(}\PYG{l+s+sAtom}{q\PYGZus{}accept}\PYG{p}{,} \PYG{k}{\PYGZus{}}\PYG{p}{,} \PYG{k}{\PYGZus{}}\PYG{p}{,} \PYG{k}{\PYGZus{}}\PYG{p}{,} \PYG{k}{\PYGZus{}}\PYG{p}{)).}

\PYG{n+nf}{final\PYGZus{}interpretation}\PYG{p}{(}\PYG{n+nf}{state}\PYG{p}{(}\PYG{l+s+sAtom}{q\PYGZus{}accept}\PYG{p}{,} \PYG{k}{\PYGZus{}}\PYG{p}{,} \PYG{k}{\PYGZus{}}\PYG{p}{,} \PYG{n+nv}{Total}\PYG{p}{,} \PYG{k}{\PYGZus{}}\PYG{p}{),} \PYG{n+nv}{Interpretation}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{format}\PYG{p}{(}\PYG{n+nf}{atom}\PYG{p}{(}\PYG{n+nv}{Interpretation}\PYG{p}{),} \PYG{l+s+sAtom}{\PYGZsq{}Calculation complete. Result = \PYGZti{}w.\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{n+nv}{Total}\PYG{p}{]).}

\PYG{n+nf}{extract\PYGZus{}result\PYGZus{}from\PYGZus{}history}\PYG{p}{(}\PYG{n+nv}{History}\PYG{p}{,} \PYG{n+nv}{Result}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{last}\PYG{p}{(}\PYG{n+nv}{History}\PYG{p}{,} \PYG{n+nv}{LastStep}\PYG{p}{),}
    \PYG{p}{(}\PYG{n+nv}{LastStep} \PYG{o}{=} \PYG{n+nf}{step}\PYG{p}{(}\PYG{n+nf}{state}\PYG{p}{(}\PYG{l+s+sAtom}{q\PYGZus{}accept}\PYG{p}{,} \PYG{k}{\PYGZus{}}\PYG{p}{,} \PYG{k}{\PYGZus{}}\PYG{p}{,} \PYG{n+nv}{Total}\PYG{p}{,} \PYG{k}{\PYGZus{}}\PYG{p}{),} \PYG{k}{\PYGZus{}}\PYG{p}{,} \PYG{k}{\PYGZus{}}\PYG{p}{)} \PYG{l+s+sAtom}{\PYGZhy{}\PYGZgt{}}
        \PYG{n+nv}{Result} \PYG{o}{=} \PYG{n+nv}{Total}
    \PYG{p}{;}
        \PYG{n+nv}{Result} \PYG{o}{=} \PYG{l+s+sAtom}{\PYGZsq{}error\PYGZsq{}}
    \PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} transition/3 defines the logic for moving from one state to the next.}

\PYG{c+c1}{\PYGZpc{} From q\PYGZus{}init\PYGZus{}calc, start the iterative calculation loop.}
\PYG{n+nf}{transition}\PYG{p}{(}\PYG{n+nf}{state}\PYG{p}{(}\PYG{l+s+sAtom}{q\PYGZus{}init\PYGZus{}calc}\PYG{p}{,} \PYG{n+nv}{Gs}\PYG{p}{,} \PYG{n+nv}{Items}\PYG{p}{,} \PYG{k}{\PYGZus{}}\PYG{p}{,} \PYG{k}{\PYGZus{}}\PYG{p}{),} \PYG{n+nf}{state}\PYG{p}{(}\PYG{l+s+sAtom}{q\PYGZus{}loop\PYGZus{}calc}\PYG{p}{,} \PYG{n+nv}{Gs}\PYG{p}{,} \PYG{n+nv}{Items}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nv}{Gs}\PYG{p}{),}
           \PYG{l+s+sAtom}{\PYGZsq{}Initializing iterative calculation.\PYGZsq{}}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} In q\PYGZus{}loop\PYGZus{}calc, add the number of items to the total and decrement the counter.}
\PYG{n+nf}{transition}\PYG{p}{(}\PYG{n+nf}{state}\PYG{p}{(}\PYG{l+s+sAtom}{q\PYGZus{}loop\PYGZus{}calc}\PYG{p}{,} \PYG{n+nv}{Gs}\PYG{p}{,} \PYG{n+nv}{Items}\PYG{p}{,} \PYG{n+nv}{Total}\PYG{p}{,} \PYG{n+nv}{Counter}\PYG{p}{),} \PYG{n+nf}{state}\PYG{p}{(}\PYG{l+s+sAtom}{q\PYGZus{}loop\PYGZus{}calc}\PYG{p}{,} \PYG{n+nv}{Gs}\PYG{p}{,} \PYG{n+nv}{Items}\PYG{p}{,} \PYG{n+nv}{NewTotal}\PYG{p}{,} \PYG{n+nv}{NewCounter}\PYG{p}{),} \PYG{n+nv}{Interp}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nv}{Counter} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{,}
    \PYG{n+nv}{NewTotal} \PYG{o}{is} \PYG{n+nv}{Total} \PYG{o}{+} \PYG{n+nv}{Items}\PYG{p}{,}
    \PYG{n+nv}{NewCounter} \PYG{o}{is} \PYG{n+nv}{Counter} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,}
    \PYG{n+nf}{format}\PYG{p}{(}\PYG{n+nf}{string}\PYG{p}{(}\PYG{n+nv}{Interp}\PYG{p}{),} \PYG{l+s+sAtom}{\PYGZsq{}Iterate: Added \PYGZti{}w. Total = \PYGZti{}w.\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{n+nv}{Items}\PYG{p}{,} \PYG{n+nv}{NewTotal}\PYG{p}{]).}
\PYG{c+c1}{\PYGZpc{} When the counter reaches zero, the calculation is complete.}
\PYG{n+nf}{transition}\PYG{p}{(}\PYG{n+nf}{state}\PYG{p}{(}\PYG{l+s+sAtom}{q\PYGZus{}loop\PYGZus{}calc}\PYG{p}{,} \PYG{k}{\PYGZus{}}\PYG{p}{,} \PYG{k}{\PYGZus{}}\PYG{p}{,} \PYG{n+nv}{Total}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{),} \PYG{n+nf}{state}\PYG{p}{(}\PYG{l+s+sAtom}{q\PYGZus{}accept}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nv}{Total}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{),}
           \PYG{l+s+sAtom}{\PYGZsq{}Calculation complete.\PYGZsq{}}\PYG{p}{).}
\end{MintedVerbatim}
