\begin{MintedVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/** \PYGZlt{}module\PYGZgt{} Object\PYGZhy{}Level Knowledge Base}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * This module represents the \PYGZdq{}object level\PYGZdq{} of the cognitive architecture.}
\PYG{c+cm}{ * It contains the initial, and potentially flawed, knowledge base that the}
\PYG{c+cm}{ * system reasons with. The predicates defined in this module are the ones}
\PYG{c+cm}{ * that are observed by the meta\PYGZhy{}interpreter and modified by the}
\PYG{c+cm}{ * reorganization engine.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * The key predicate `add/3` is declared as `dynamic` because it is the}
\PYG{c+cm}{ * target of learning and reorganization. Its initial implementation is}
\PYG{c+cm}{ * deliberately inefficient to create opportunities for the system to detect}
\PYG{c+cm}{ * disequilibrium and self\PYGZhy{}improve.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * }
\PYG{c+cm}{ * }
\PYG{c+cm}{ */}
\PYG{p}{:\PYGZhy{}} \PYG{n+nf}{module}\PYG{p}{(}\PYG{l+s+sAtom}{object\PYGZus{}level}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+sAtom}{add}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+s+sAtom}{subtract}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+s+sAtom}{multiply}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+s+sAtom}{divide}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{]).}

\PYG{p}{:\PYGZhy{}} \PYG{n+nf}{use\PYGZus{}module}\PYG{p}{(}\PYG{l+s+sAtom}{grounded\PYGZus{}arithmetic}\PYG{p}{).}

\PYG{p}{:\PYGZhy{}} \PYG{l+s+sAtom}{dynamic} \PYG{l+s+sAtom}{add}\PYG{o}{/}\PYG{l+m+mf}{3.}
\PYG{p}{:\PYGZhy{}} \PYG{l+s+sAtom}{dynamic} \PYG{l+s+sAtom}{subtract}\PYG{o}{/}\PYG{l+m+mf}{3.}
\PYG{p}{:\PYGZhy{}} \PYG{l+s+sAtom}{dynamic} \PYG{l+s+sAtom}{multiply}\PYG{o}{/}\PYG{l+m+mf}{3.}
\PYG{p}{:\PYGZhy{}} \PYG{l+s+sAtom}{dynamic} \PYG{l+s+sAtom}{divide}\PYG{o}{/}\PYG{l+m+mf}{3.}

\PYG{c+c1}{\PYGZpc{} enumerate/1}
\PYG{c+c1}{\PYGZpc{} Helper to force enumeration of a Peano number. Its primary purpose}
\PYG{c+c1}{\PYGZpc{} in this context is to consume inference steps in the meta\PYGZhy{}interpreter,}
\PYG{c+c1}{\PYGZpc{} making the initial `add/3` implementation inefficient and prone to}
\PYG{c+c1}{\PYGZpc{} resource exhaustion, which acts as a trigger for reorganization.}
\PYG{n+nf}{enumerate}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{).}
\PYG{n+nf}{enumerate}\PYG{p}{(}\PYG{n+nf}{s}\PYG{p}{(}\PYG{n+nv}{N}\PYG{p}{))} \PYG{p}{:\PYGZhy{}} \PYG{n+nf}{enumerate}\PYG{p}{(}\PYG{n+nv}{N}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} recursive\PYGZus{}add/3}
\PYG{c+c1}{\PYGZpc{} This is the standard, efficient, recursive definition of addition for}
\PYG{c+c1}{\PYGZpc{} Peano numbers. It serves as the \PYGZdq{}correct\PYGZdq{} implementation that the}
\PYG{c+c1}{\PYGZpc{} reorganization engine will synthesize and assert when the initial,}
\PYG{c+c1}{\PYGZpc{} inefficient `add/3` rule is retracted.}
\PYG{n+nf}{recursive\PYGZus{}add}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{).}
\PYG{n+nf}{recursive\PYGZus{}add}\PYG{p}{(}\PYG{n+nf}{s}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{),} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nf}{s}\PYG{p}{(}\PYG{n+nv}{Sum}\PYG{p}{))} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{recursive\PYGZus{}add}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{Sum}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{}!      add(?A, ?B, ?Sum) is nondet.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       The initial, inefficient definition of addition.}
\PYG{c+c1}{\PYGZpc{}       This predicate is designed to simulate a \PYGZdq{}counting\PYGZhy{}all\PYGZdq{} strategy. It}
\PYG{c+c1}{\PYGZpc{}       works by first completely grounding the two inputs `A` and `B` by}
\PYG{c+c1}{\PYGZpc{}       recursively calling `enumerate/1`. This process is computationally}
\PYG{c+c1}{\PYGZpc{}       expensive and is intended to fail (by resource exhaustion) for larger}
\PYG{c+c1}{\PYGZpc{}       numbers, thus triggering the ORR learning cycle.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       This predicate is declared `dynamic` and will be replaced by a more}
\PYG{c+c1}{\PYGZpc{}       efficient version by the `reorganization\PYGZus{}engine`.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       @param A A Peano number representing the first addend.}
\PYG{c+c1}{\PYGZpc{}       @param B A Peano number representing the second addend.}
\PYG{c+c1}{\PYGZpc{}       @param Sum The Peano number representing the sum of A and B.}
\PYG{n+nf}{add}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{Sum}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{enumerate}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{),}
    \PYG{n+nf}{enumerate}\PYG{p}{(}\PYG{n+nv}{B}\PYG{p}{),}
    \PYG{n+nf}{recursive\PYGZus{}add}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{Sum}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{}!      multiply(?A, ?B, ?Product) is nondet.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       The initial, inefficient definition of multiplication.}
\PYG{c+c1}{\PYGZpc{}       This predicate is designed to simulate multiplication via repeated}
\PYG{c+c1}{\PYGZpc{}       addition. It is computationally expensive and intended to trigger}
\PYG{c+c1}{\PYGZpc{}       reorganization for larger numbers.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       This predicate is declared `dynamic` and will be replaced by a more}
\PYG{c+c1}{\PYGZpc{}       efficient version by the `reorganization\PYGZus{}engine`.}
\PYG{n+nf}{multiply}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{Product}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{enumerate}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{),}
    \PYG{n+nf}{enumerate}\PYG{p}{(}\PYG{n+nv}{B}\PYG{p}{),}
    \PYG{n+nf}{recursive\PYGZus{}multiply}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{Product}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} recursive\PYGZus{}multiply/3}
\PYG{c+c1}{\PYGZpc{} This is the standard, efficient, recursive definition of multiplication.}
\PYG{n+nf}{recursive\PYGZus{}multiply}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k}{\PYGZus{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{).}
\PYG{n+nf}{recursive\PYGZus{}multiply}\PYG{p}{(}\PYG{n+nf}{s}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{),} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{Product}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{recursive\PYGZus{}multiply}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{PartialProduct}\PYG{p}{),}
    \PYG{n+nf}{add}\PYG{p}{(}\PYG{n+nv}{PartialProduct}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{Product}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} recursive\PYGZus{}subtract/3}
\PYG{c+c1}{\PYGZpc{} The standard, efficient recursive definition of subtraction for Peano numbers.}
\PYG{c+c1}{\PYGZpc{} This will be synthesized by the reorganization engine.}
\PYG{n+nf}{recursive\PYGZus{}subtract}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nv}{A}\PYG{p}{).}
\PYG{n+nf}{recursive\PYGZus{}subtract}\PYG{p}{(}\PYG{n+nf}{s}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{),} \PYG{n+nf}{s}\PYG{p}{(}\PYG{n+nv}{B}\PYG{p}{),} \PYG{n+nv}{Difference}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{recursive\PYGZus{}subtract}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{Difference}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{}!      subtract(?Minuend, ?Subtrahend, ?Difference) is nondet.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       The initial, inefficient definition of subtraction.}
\PYG{c+c1}{\PYGZpc{}       Like add/3, this deliberately enumerates both inputs to trigger}
\PYG{c+c1}{\PYGZpc{}       reorganization. It uses the grounded arithmetic to avoid the}
\PYG{c+c1}{\PYGZpc{}       Prolog arithmetic backstop.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       @param Minuend A Peano number to subtract from.}
\PYG{c+c1}{\PYGZpc{}       @param Subtrahend A Peano number to subtract.}
\PYG{c+c1}{\PYGZpc{}       @param Difference The result of Minuend \PYGZhy{} Subtrahend.}
\PYG{n+nf}{subtract}\PYG{p}{(}\PYG{n+nv}{Minuend}\PYG{p}{,} \PYG{n+nv}{Subtrahend}\PYG{p}{,} \PYG{n+nv}{Difference}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{enumerate}\PYG{p}{(}\PYG{n+nv}{Minuend}\PYG{p}{),}
    \PYG{n+nf}{enumerate}\PYG{p}{(}\PYG{n+nv}{Subtrahend}\PYG{p}{),}
    \PYG{n+nf}{recursive\PYGZus{}subtract}\PYG{p}{(}\PYG{n+nv}{Minuend}\PYG{p}{,} \PYG{n+nv}{Subtrahend}\PYG{p}{,} \PYG{n+nv}{Difference}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} recursive\PYGZus{}divide/3  }
\PYG{c+c1}{\PYGZpc{} The standard definition of division for Peano numbers via repeated subtraction.}
\PYG{n+nf}{recursive\PYGZus{}divide}\PYG{p}{(}\PYG{n+nv}{Dividend}\PYG{p}{,} \PYG{n+nv}{Divisor}\PYG{p}{,} \PYG{n+nv}{Quotient}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{recursive\PYGZus{}divide\PYGZus{}helper}\PYG{p}{(}\PYG{n+nv}{Dividend}\PYG{p}{,} \PYG{n+nv}{Divisor}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nv}{Quotient}\PYG{p}{).}

\PYG{n+nf}{recursive\PYGZus{}divide\PYGZus{}helper}\PYG{p}{(}\PYG{n+nv}{Remainder}\PYG{p}{,} \PYG{n+nv}{Divisor}\PYG{p}{,} \PYG{n+nv}{AccQuotient}\PYG{p}{,} \PYG{n+nv}{Quotient}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{p}{(} \PYG{n+nf}{recursive\PYGZus{}subtract}\PYG{p}{(}\PYG{n+nv}{Remainder}\PYG{p}{,} \PYG{n+nv}{Divisor}\PYG{p}{,} \PYG{n+nv}{NewRemainder}\PYG{p}{)} \PYG{l+s+sAtom}{\PYGZhy{}\PYGZgt{}}
        \PYG{n+nf}{recursive\PYGZus{}add}\PYG{p}{(}\PYG{n+nv}{AccQuotient}\PYG{p}{,} \PYG{n+nf}{s}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{),} \PYG{n+nv}{NewAccQuotient}\PYG{p}{),}
        \PYG{n+nf}{recursive\PYGZus{}divide\PYGZus{}helper}\PYG{p}{(}\PYG{n+nv}{NewRemainder}\PYG{p}{,} \PYG{n+nv}{Divisor}\PYG{p}{,} \PYG{n+nv}{NewAccQuotient}\PYG{p}{,} \PYG{n+nv}{Quotient}\PYG{p}{)}
    \PYG{p}{;}
        \PYG{n+nv}{Quotient} \PYG{o}{=} \PYG{n+nv}{AccQuotient}
    \PYG{p}{).}

\PYG{c+c1}{\PYGZpc{}!      divide(?Dividend, ?Divisor, ?Quotient) is nondet.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       The initial, inefficient definition of division.}
\PYG{c+c1}{\PYGZpc{}       Enumerates inputs and uses repeated subtraction to compute quotient.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       @param Dividend A Peano number to be divided.}
\PYG{c+c1}{\PYGZpc{}       @param Divisor A Peano number to divide by.}
\PYG{c+c1}{\PYGZpc{}       @param Quotient The result of Dividend / Divisor.}
\PYG{n+nf}{divide}\PYG{p}{(}\PYG{n+nv}{Dividend}\PYG{p}{,} \PYG{n+nv}{Divisor}\PYG{p}{,} \PYG{n+nv}{Quotient}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{enumerate}\PYG{p}{(}\PYG{n+nv}{Dividend}\PYG{p}{),}
    \PYG{n+nf}{enumerate}\PYG{p}{(}\PYG{n+nv}{Divisor}\PYG{p}{),}
    \PYG{l+s+sAtom}{\PYGZbs{}+} \PYG{p}{(}\PYG{n+nv}{Divisor} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{),}  \PYG{c+c1}{\PYGZpc{} Prevent division by zero}
    \PYG{n+nf}{recursive\PYGZus{}divide}\PYG{p}{(}\PYG{n+nv}{Dividend}\PYG{p}{,} \PYG{n+nv}{Divisor}\PYG{p}{,} \PYG{n+nv}{Quotient}\PYG{p}{).}
\end{MintedVerbatim}
