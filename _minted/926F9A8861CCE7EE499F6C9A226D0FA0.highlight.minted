\begin{MintedVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/** \PYGZlt{}module\PYGZgt{} Object\PYGZhy{}Level Knowledge Base}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * This module represents the \PYGZdq{}object level\PYGZdq{} of the cognitive architecture.}
\PYG{c+cm}{ * It contains the initial, and potentially flawed, knowledge base that the}
\PYG{c+cm}{ * system reasons with. The predicates defined in this module are the ones}
\PYG{c+cm}{ * that are observed by the meta\PYGZhy{}interpreter and modified by the}
\PYG{c+cm}{ * reorganization engine.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * The key predicate `add/3` is declared as `dynamic` because it is the}
\PYG{c+cm}{ * target of learning and reorganization. Its initial implementation is}
\PYG{c+cm}{ * deliberately inefficient to create opportunities for the system to detect}
\PYG{c+cm}{ * disequilibrium and self\PYGZhy{}improve.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * @author Tilo Wiedera}
\PYG{c+cm}{ * @license MIT}
\PYG{c+cm}{ */}
\PYG{p}{:\PYGZhy{}} \PYG{n+nf}{module}\PYG{p}{(}\PYG{l+s+sAtom}{object\PYGZus{}level}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+sAtom}{add}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+s+sAtom}{multiply}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{]).}

\PYG{p}{:\PYGZhy{}} \PYG{l+s+sAtom}{dynamic} \PYG{l+s+sAtom}{add}\PYG{o}{/}\PYG{l+m+mf}{3.}
\PYG{p}{:\PYGZhy{}} \PYG{l+s+sAtom}{dynamic} \PYG{l+s+sAtom}{multiply}\PYG{o}{/}\PYG{l+m+mf}{3.}

\PYG{c+c1}{\PYGZpc{} enumerate/1}
\PYG{c+c1}{\PYGZpc{} Helper to force enumeration of a Peano number. Its primary purpose}
\PYG{c+c1}{\PYGZpc{} in this context is to consume inference steps in the meta\PYGZhy{}interpreter,}
\PYG{c+c1}{\PYGZpc{} making the initial `add/3` implementation inefficient and prone to}
\PYG{c+c1}{\PYGZpc{} resource exhaustion, which acts as a trigger for reorganization.}
\PYG{n+nf}{enumerate}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{).}
\PYG{n+nf}{enumerate}\PYG{p}{(}\PYG{n+nf}{s}\PYG{p}{(}\PYG{n+nv}{N}\PYG{p}{))} \PYG{p}{:\PYGZhy{}} \PYG{n+nf}{enumerate}\PYG{p}{(}\PYG{n+nv}{N}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} recursive\PYGZus{}add/3}
\PYG{c+c1}{\PYGZpc{} This is the standard, efficient, recursive definition of addition for}
\PYG{c+c1}{\PYGZpc{} Peano numbers. It serves as the \PYGZdq{}correct\PYGZdq{} implementation that the}
\PYG{c+c1}{\PYGZpc{} reorganization engine will synthesize and assert when the initial,}
\PYG{c+c1}{\PYGZpc{} inefficient `add/3` rule is retracted.}
\PYG{n+nf}{recursive\PYGZus{}add}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{).}
\PYG{n+nf}{recursive\PYGZus{}add}\PYG{p}{(}\PYG{n+nf}{s}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{),} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nf}{s}\PYG{p}{(}\PYG{n+nv}{Sum}\PYG{p}{))} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{recursive\PYGZus{}add}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{Sum}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{}!      add(?A, ?B, ?Sum) is nondet.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       The initial, inefficient definition of addition.}
\PYG{c+c1}{\PYGZpc{}       This predicate is designed to simulate a \PYGZdq{}counting\PYGZhy{}all\PYGZdq{} strategy. It}
\PYG{c+c1}{\PYGZpc{}       works by first completely grounding the two inputs `A` and `B` by}
\PYG{c+c1}{\PYGZpc{}       recursively calling `enumerate/1`. This process is computationally}
\PYG{c+c1}{\PYGZpc{}       expensive and is intended to fail (by resource exhaustion) for larger}
\PYG{c+c1}{\PYGZpc{}       numbers, thus triggering the ORR learning cycle.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       This predicate is declared `dynamic` and will be replaced by a more}
\PYG{c+c1}{\PYGZpc{}       efficient version by the `reorganization\PYGZus{}engine`.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       @param A A Peano number representing the first addend.}
\PYG{c+c1}{\PYGZpc{}       @param B A Peano number representing the second addend.}
\PYG{c+c1}{\PYGZpc{}       @param Sum The Peano number representing the sum of A and B.}
\PYG{n+nf}{add}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{Sum}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{enumerate}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{),}
    \PYG{n+nf}{enumerate}\PYG{p}{(}\PYG{n+nv}{B}\PYG{p}{),}
    \PYG{n+nf}{recursive\PYGZus{}add}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{Sum}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{}!      multiply(?A, ?B, ?Product) is nondet.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       The initial, inefficient definition of multiplication.}
\PYG{c+c1}{\PYGZpc{}       This predicate is designed to simulate multiplication via repeated}
\PYG{c+c1}{\PYGZpc{}       addition. It is computationally expensive and intended to trigger}
\PYG{c+c1}{\PYGZpc{}       reorganization for larger numbers.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       This predicate is declared `dynamic` and will be replaced by a more}
\PYG{c+c1}{\PYGZpc{}       efficient version by the `reorganization\PYGZus{}engine`.}
\PYG{n+nf}{multiply}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{Product}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{enumerate}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{),}
    \PYG{n+nf}{enumerate}\PYG{p}{(}\PYG{n+nv}{B}\PYG{p}{),}
    \PYG{n+nf}{recursive\PYGZus{}multiply}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{Product}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} recursive\PYGZus{}multiply/3}
\PYG{c+c1}{\PYGZpc{} This is the standard, efficient, recursive definition of multiplication.}
\PYG{n+nf}{recursive\PYGZus{}multiply}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k}{\PYGZus{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{).}
\PYG{n+nf}{recursive\PYGZus{}multiply}\PYG{p}{(}\PYG{n+nf}{s}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{),} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{Product}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{recursive\PYGZus{}multiply}\PYG{p}{(}\PYG{n+nv}{A}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{PartialProduct}\PYG{p}{),}
    \PYG{n+nf}{add}\PYG{p}{(}\PYG{n+nv}{PartialProduct}\PYG{p}{,} \PYG{n+nv}{B}\PYG{p}{,} \PYG{n+nv}{Product}\PYG{p}{).}
\end{MintedVerbatim}
