\begin{MintedVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/** \PYGZlt{}module\PYGZgt{} Simple Strategy Resolution Model}
\PYG{c+cm}{ *}
\PYG{c+cm}{ *  This module provides a simple, self\PYGZhy{}contained model for resolving the}
\PYG{c+cm}{ *  outputs from multiple, potentially conflicting, information sources or}
\PYG{c+cm}{ *  \PYGZdq{}strategies\PYGZdq{}. It is a conceptual demonstration and is not integrated with}
\PYG{c+cm}{ *  the main ORR cycle or the other learner modules.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ *  The model consists of two parts:}
\PYG{c+cm}{ *  1.  A database of facts (`strategy\PYGZus{}output/4`) that simulates the results}
\PYG{c+cm}{ *      produced by different named strategies for various problems.}
\PYG{c+cm}{ *  2.  A `compute/3` predicate that gathers all possible results for a given}
\PYG{c+cm}{ *      problem and uses a `resolve/2` helper to determine the final outcome}
\PYG{c+cm}{ *      based on a simple semantic:}
\PYG{c+cm}{ *      \PYGZhy{} If all strategies agree, that is the result.}
\PYG{c+cm}{ *      \PYGZhy{} If strategies disagree, the result is `incompatible`.}
\PYG{c+cm}{ *      \PYGZhy{} If no strategy can solve the problem, the result is `unknown`.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * @author Tilo Wiedera}
\PYG{c+cm}{ * @license MIT}
\PYG{c+cm}{ */}
\PYG{p}{:\PYGZhy{}} \PYG{n+nf}{module}\PYG{p}{(}\PYG{l+s+sAtom}{learner\PYGZus{}1}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+sAtom}{compute}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{]).}

\PYG{p}{:\PYGZhy{}} \PYG{n+nf}{use\PYGZus{}module}\PYG{p}{(}\PYG{n+nf}{library}\PYG{p}{(}\PYG{l+s+sAtom}{lists}\PYG{p}{)).}

\PYG{c+c1}{\PYGZpc{} \PYGZhy{}\PYGZhy{}\PYGZhy{} A. DATABASE OF STRATEGY OUTPUTS \PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZpc{} This section simulates the results from different strategies.}
\PYG{c+c1}{\PYGZpc{} Format: strategy\PYGZus{}output(StrategyName, Operation, InputsList, Result).}

\PYG{c+c1}{\PYGZpc{} Case 1: Agreement}
\PYG{c+c1}{\PYGZpc{} Both strategy\PYGZus{}a and strategy\PYGZus{}b correctly compute 2 + 3.}
\PYG{n+nf}{strategy\PYGZus{}output}\PYG{p}{(}\PYG{l+s+sAtom}{strategy\PYGZus{}a}\PYG{p}{,} \PYG{l+s+sAtom}{add}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{],} \PYG{l+m+mi}{5}\PYG{p}{).}
\PYG{n+nf}{strategy\PYGZus{}output}\PYG{p}{(}\PYG{l+s+sAtom}{strategy\PYGZus{}b}\PYG{p}{,} \PYG{l+s+sAtom}{add}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{],} \PYG{l+m+mi}{5}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} Case 2: Incompatibility (Disagreement)}
\PYG{c+c1}{\PYGZpc{} strategy\PYGZus{}a correctly computes 5 \PYGZhy{} 1, but strategy\PYGZus{}c gets it wrong.}
\PYG{n+nf}{strategy\PYGZus{}output}\PYG{p}{(}\PYG{l+s+sAtom}{strategy\PYGZus{}a}\PYG{p}{,} \PYG{l+s+sAtom}{subtract}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{],} \PYG{l+m+mi}{4}\PYG{p}{).}
\PYG{n+nf}{strategy\PYGZus{}output}\PYG{p}{(}\PYG{l+s+sAtom}{strategy\PYGZus{}c}\PYG{p}{,} \PYG{l+s+sAtom}{subtract}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{],} \PYG{l+m+mi}{6}\PYG{p}{).} \PYG{c+c1}{\PYGZpc{} Incorrect result}

\PYG{c+c1}{\PYGZpc{} Case 3: Single Available Strategy}
\PYG{c+c1}{\PYGZpc{} Only strategy\PYGZus{}b knows how to multiply.}
\PYG{n+nf}{strategy\PYGZus{}output}\PYG{p}{(}\PYG{l+s+sAtom}{strategy\PYGZus{}b}\PYG{p}{,} \PYG{l+s+sAtom}{multiply}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{],} \PYG{l+m+mi}{20}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} \PYGZhy{}\PYGZhy{}\PYGZhy{} B. RULES FOR COMPUTATION \PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZpc{} This section implements the logic to compute a final result.}

\PYG{c+c1}{\PYGZpc{} resolve(+ListOfResults, \PYGZhy{}FinalResult)}
\PYG{c+c1}{\PYGZpc{} This helper predicate applies the semantics to a list of gathered results.}

\PYG{c+c1}{\PYGZpc{} Rule 1: If the list of results is empty, the answer is \PYGZsq{}unknown\PYGZsq{}.}
\PYG{n+nf}{resolve}\PYG{p}{([],} \PYG{l+s+sAtom}{unknown}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} Rule 2: If the list of results contains different values, it\PYGZsq{}s \PYGZsq{}incompatible\PYGZsq{}.}
\PYG{c+c1}{\PYGZpc{} We convert the list to a set. If the set has more than one member, there was a disagreement.}
\PYG{n+nf}{resolve}\PYG{p}{(}\PYG{n+nv}{ResultsList}\PYG{p}{,} \PYG{l+s+sAtom}{incompatible}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{list\PYGZus{}to\PYGZus{}set}\PYG{p}{(}\PYG{n+nv}{ResultsList}\PYG{p}{,} \PYG{n+nv}{Set}\PYG{p}{),}
    \PYG{n+nf}{length}\PYG{p}{(}\PYG{n+nv}{Set}\PYG{p}{,} \PYG{n+nv}{L}\PYG{p}{),}
    \PYG{n+nv}{L} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{1.}

\PYG{c+c1}{\PYGZpc{} Rule 3: If the list of results contains one or more identical values, that is the answer.}
\PYG{c+c1}{\PYGZpc{} After converting to a set, there will be exactly one element.}
\PYG{n+nf}{resolve}\PYG{p}{(}\PYG{n+nv}{ResultsList}\PYG{p}{,} \PYG{n+nv}{Result}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{list\PYGZus{}to\PYGZus{}set}\PYG{p}{(}\PYG{n+nv}{ResultsList}\PYG{p}{,} \PYG{n+nv}{Set}\PYG{p}{),}
    \PYG{n+nf}{length}\PYG{p}{(}\PYG{n+nv}{Set}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{),}
    \PYG{p}{[}\PYG{n+nv}{Result}\PYG{p}{]} \PYG{o}{=} \PYG{n+nv}{Set}\PYG{p}{.}

\PYG{c+c1}{\PYGZpc{}!      compute(+Op:atom, +Inputs:list, \PYGZhy{}Result) is det.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       Computes the result for a given operation and inputs by polling all}
\PYG{c+c1}{\PYGZpc{}       available strategies and resolving their outputs.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       It uses `findall/3` to collect all possible results from the}
\PYG{c+c1}{\PYGZpc{}       `strategy\PYGZus{}output/4` database for the given `Op` and `Inputs`. It then}
\PYG{c+c1}{\PYGZpc{}       passes this list of results to `resolve/2` to determine the final,}
\PYG{c+c1}{\PYGZpc{}       semantically coherent result.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       @param Op The operation to perform (e.g., `add`, `subtract`).}
\PYG{c+c1}{\PYGZpc{}       @param Inputs A list of input numbers for the operation.}
\PYG{c+c1}{\PYGZpc{}       @param Result The final resolved result, which can be a number,}
\PYG{c+c1}{\PYGZpc{}       the atom `incompatible`, or the atom `unknown`.}
\PYG{n+nf}{compute}\PYG{p}{(}\PYG{n+nv}{Op}\PYG{p}{,} \PYG{n+nv}{Inputs}\PYG{p}{,} \PYG{n+nv}{Result}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{c+c1}{\PYGZpc{} Step 1: Find all results from all available strategies for the given problem.}
    \PYG{n+nf}{findall}\PYG{p}{(}\PYG{n+nv}{R}\PYG{p}{,} \PYG{n+nf}{strategy\PYGZus{}output}\PYG{p}{(}\PYG{k}{\PYGZus{}}\PYG{p}{,} \PYG{n+nv}{Op}\PYG{p}{,} \PYG{n+nv}{Inputs}\PYG{p}{,} \PYG{n+nv}{R}\PYG{p}{),} \PYG{n+nv}{ResultsList}\PYG{p}{),}

    \PYG{c+c1}{\PYGZpc{} Step 2: Resolve the collected list of results using our semantics.}
    \PYG{n+nf}{resolve}\PYG{p}{(}\PYG{n+nv}{ResultsList}\PYG{p}{,} \PYG{n+nv}{Result}\PYG{p}{).}
\end{MintedVerbatim}
