\begin{MintedVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/** \PYGZlt{}module\PYGZgt{} Reflective Monitor for Disequilibrium Detection}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * This module implements the \PYGZdq{}Reflect\PYGZdq{} stage of the ORR cycle. Its primary}
\PYG{c+cm}{ * role is to analyze the execution trace produced by the meta\PYGZhy{}interpreter}
\PYG{c+cm}{ * (`meta\PYGZus{}interpreter.pl`) and detect signs of \PYGZdq{}disequilibrium.\PYGZdq{}}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * Disequilibrium can manifest in two main ways:}
\PYG{c+cm}{ * 1.  **Goal Failure**: The system was unable to find a proof for the goal.}
\PYG{c+cm}{ * 2.  **Logical Incoherence**: The proof that was found relies on a set of}
\PYG{c+cm}{ *     commitments (clauses) that are logically inconsistent with each other,}
\PYG{c+cm}{ *     as determined by `incompatibility\PYGZus{}semantics.pl`.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * This module also maintains a \PYGZdq{}conceptual stress map,\PYGZdq{} which tracks how}
\PYG{c+cm}{ * often certain predicates are involved in failures. This map can be used by}
\PYG{c+cm}{ * the reorganization engine to guide its search for a solution.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * The stress map is stored as dynamic facts of the form:}
\PYG{c+cm}{ * `stress(PredicateSignature, Count)`.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * }
\PYG{c+cm}{ * }
\PYG{c+cm}{ */}
\PYG{p}{:\PYGZhy{}} \PYG{n+nf}{module}\PYG{p}{(}\PYG{l+s+sAtom}{reflective\PYGZus{}monitor}\PYG{p}{,} \PYG{p}{[}
    \PYG{l+s+sAtom}{reflect}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}
    \PYG{l+s+sAtom}{get\PYGZus{}stress\PYGZus{}map}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{p}{,}
    \PYG{l+s+sAtom}{reset\PYGZus{}stress\PYGZus{}map}\PYG{o}{/}\PYG{l+m+mi}{0}
\PYG{p}{]).}

\PYG{p}{:\PYGZhy{}} \PYG{n+nf}{use\PYGZus{}module}\PYG{p}{(}\PYG{l+s+sAtom}{incompatibility\PYGZus{}semantics}\PYG{p}{).}

\PYG{p}{:\PYGZhy{}} \PYG{l+s+sAtom}{dynamic} \PYG{l+s+sAtom}{stress}\PYG{o}{/}\PYG{l+m+mf}{2.}

\PYG{c+c1}{\PYGZpc{}!      reflect(+Trace:list, \PYGZhy{}DisequilibriumTrigger:term) is semidet.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       Analyzes an execution trace from the meta\PYGZhy{}interpreter to detect}
\PYG{c+c1}{\PYGZpc{}       disequilibrium. It succeeds if a trigger for disequilibrium is found,}
\PYG{c+c1}{\PYGZpc{}       binding `DisequilibriumTrigger` to a term describing the issue. It}
\PYG{c+c1}{\PYGZpc{}       fails if the trace represents a state of equilibrium (i.e., the goal}
\PYG{c+c1}{\PYGZpc{}       succeeded and its premises are coherent).}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       The process involves:}
\PYG{c+c1}{\PYGZpc{}       1. Parsing the trace to separate successful commitments from failures.}
\PYG{c+c1}{\PYGZpc{}       2. Updating a conceptual stress map based on any failures.}
\PYG{c+c1}{\PYGZpc{}       3. Checking for disequilibrium triggers, prioritizing goal failure over}
\PYG{c+c1}{\PYGZpc{}          incoherence.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       @param Trace The execution trace generated by `solve/4`.}
\PYG{c+c1}{\PYGZpc{}       @param DisequilibriumTrigger A term describing the reason for}
\PYG{c+c1}{\PYGZpc{}       disequilibrium, e.g., `goal\PYGZus{}failure([...])` or `incoherence([...])`.}
\PYG{n+nf}{reflect}\PYG{p}{(}\PYG{n+nv}{Trace}\PYG{p}{,} \PYG{n+nv}{Trigger}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{c+c1}{\PYGZpc{} 1. Parse the trace to extract commitments and failures.}
    \PYG{n+nf}{parse\PYGZus{}trace}\PYG{p}{(}\PYG{n+nv}{Trace}\PYG{p}{,} \PYG{n+nv}{Commitments}\PYG{p}{,} \PYG{n+nv}{Failures}\PYG{p}{),}

    \PYG{c+c1}{\PYGZpc{} 2. Update the conceptual stress map based on failures.}
    \PYG{n+nf}{update\PYGZus{}stress\PYGZus{}map}\PYG{p}{(}\PYG{n+nv}{Failures}\PYG{p}{),}

    \PYG{c+c1}{\PYGZpc{} 3. Check for disequilibrium triggers.}
    \PYG{p}{(}
        \PYG{c+c1}{\PYGZpc{} Trigger 1: Goal Failure}
        \PYG{n+nv}{Failures} \PYG{l+s+sAtom}{\PYGZbs{}=} \PYG{p}{[],}
        \PYG{n+nv}{Trigger} \PYG{o}{=} \PYG{n+nf}{goal\PYGZus{}failure}\PYG{p}{(}\PYG{n+nv}{Failures}\PYG{p}{),} \PYG{p}{!}
    \PYG{p}{;}
        \PYG{c+c1}{\PYGZpc{} Trigger 2: Logical Incoherence}
        \PYG{n+nf}{incoherent}\PYG{p}{(}\PYG{n+nv}{Commitments}\PYG{p}{),}
        \PYG{n+nv}{Trigger} \PYG{o}{=} \PYG{n+nf}{incoherence}\PYG{p}{(}\PYG{n+nv}{Commitments}\PYG{p}{),} \PYG{p}{!}
    \PYG{p}{).}


\PYG{c+c1}{\PYGZpc{} parse\PYGZus{}trace(+Trace, \PYGZhy{}Commitments, \PYGZhy{}Failures)}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{} Recursively walks the trace structure generated by the meta\PYGZhy{}interpreter}
\PYG{c+c1}{\PYGZpc{} and extracts the list of commitments (clauses used) and failures.}
\PYG{n+nf}{parse\PYGZus{}trace}\PYG{p}{(}\PYG{n+nv}{Trace}\PYG{p}{,} \PYG{n+nv}{Commitments}\PYG{p}{,} \PYG{n+nv}{Failures}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{parse\PYGZus{}trace\PYGZus{}recursive}\PYG{p}{(}\PYG{n+nv}{Trace}\PYG{p}{,} \PYG{n+nv}{Commitments\PYGZus{}Nested}\PYG{p}{,} \PYG{n+nv}{Failures\PYGZus{}Nested}\PYG{p}{),}
    \PYG{n+nf}{flatten}\PYG{p}{(}\PYG{n+nv}{Commitments\PYGZus{}Nested}\PYG{p}{,} \PYG{n+nv}{Commitments}\PYG{p}{),}
    \PYG{n+nf}{flatten}\PYG{p}{(}\PYG{n+nv}{Failures\PYGZus{}Nested}\PYG{p}{,} \PYG{n+nv}{Failures}\PYG{p}{).}

\PYG{n+nf}{parse\PYGZus{}trace\PYGZus{}recursive}\PYG{p}{([],} \PYG{p}{[],} \PYG{p}{[]).}
\PYG{n+nf}{parse\PYGZus{}trace\PYGZus{}recursive}\PYG{p}{([}\PYG{n+nv}{Event}\PYG{p}{|}\PYG{n+nv}{Events}\PYG{p}{],} \PYG{p}{[}\PYG{n+nv}{Commitments}\PYG{p}{|}\PYG{n+nv}{Other\PYGZus{}Cs}\PYG{p}{],} \PYG{p}{[}\PYG{n+nv}{Failures}\PYG{p}{|}\PYG{n+nv}{Other\PYGZus{}Fs}\PYG{p}{])} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{parse\PYGZus{}event}\PYG{p}{(}\PYG{n+nv}{Event}\PYG{p}{,} \PYG{n+nv}{Commitments}\PYG{p}{,} \PYG{n+nv}{Failures}\PYG{p}{),}
    \PYG{n+nf}{parse\PYGZus{}trace\PYGZus{}recursive}\PYG{p}{(}\PYG{n+nv}{Events}\PYG{p}{,} \PYG{n+nv}{Other\PYGZus{}Cs}\PYG{p}{,} \PYG{n+nv}{Other\PYGZus{}Fs}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{} How to handle each type of trace event.}
\PYG{n+nf}{parse\PYGZus{}event}\PYG{p}{(}\PYG{n+nf}{trace}\PYG{p}{(}\PYG{k}{\PYGZus{}}\PYG{p}{,} \PYG{n+nv}{SubTrace}\PYG{p}{),} \PYG{n+nv}{C}\PYG{p}{,} \PYG{n+nv}{F}\PYG{p}{)} \PYG{p}{:\PYGZhy{}} \PYG{n+nf}{parse\PYGZus{}trace\PYGZus{}recursive}\PYG{p}{(}\PYG{n+nv}{SubTrace}\PYG{p}{,} \PYG{n+nv}{C}\PYG{p}{,} \PYG{n+nv}{F}\PYG{p}{).}
\PYG{n+nf}{parse\PYGZus{}event}\PYG{p}{(}\PYG{n+nf}{clause}\PYG{p}{(}\PYG{n+nv}{Clause}\PYG{p}{),} \PYG{p}{[}\PYG{n+nv}{Clause}\PYG{p}{],} \PYG{p}{[]).}
\PYG{n+nf}{parse\PYGZus{}event}\PYG{p}{(}\PYG{n+nf}{fail}\PYG{p}{(}\PYG{n+nv}{Goal}\PYG{p}{),} \PYG{p}{[],} \PYG{p}{[}\PYG{n+nf}{fail}\PYG{p}{(}\PYG{n+nv}{Goal}\PYG{p}{)]).}
\PYG{n+nf}{parse\PYGZus{}event}\PYG{p}{(}\PYG{n+nf}{call}\PYG{p}{(}\PYG{k}{\PYGZus{}}\PYG{p}{),} \PYG{p}{[],} \PYG{p}{[]).} \PYG{c+c1}{\PYGZpc{} Built\PYGZhy{}in calls are not commitments in this context.}


\PYG{c+c1}{\PYGZpc{} update\PYGZus{}stress\PYGZus{}map(+Failures)}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{} For each failed goal, identify the clause signature and increment its stress level.}
\PYG{n+nf}{update\PYGZus{}stress\PYGZus{}map}\PYG{p}{([]).}
\PYG{n+nf}{update\PYGZus{}stress\PYGZus{}map}\PYG{p}{([}\PYG{n+nf}{fail}\PYG{p}{(}\PYG{n+nv}{Goal}\PYG{p}{)|}\PYG{n+nv}{Failures}\PYG{p}{])} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{functor}\PYG{p}{(}\PYG{n+nv}{Goal}\PYG{p}{,} \PYG{n+nv}{Name}\PYG{p}{,} \PYG{n+nv}{Arity}\PYG{p}{),}
    \PYG{n+nf}{increment\PYGZus{}stress}\PYG{p}{(}\PYG{n+nv}{Name}\PYG{o}{/}\PYG{n+nv}{Arity}\PYG{p}{),}
    \PYG{n+nf}{update\PYGZus{}stress\PYGZus{}map}\PYG{p}{(}\PYG{n+nv}{Failures}\PYG{p}{).}

\PYG{n+nf}{increment\PYGZus{}stress}\PYG{p}{(}\PYG{n+nv}{Signature}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{p}{(}   \PYG{n+nf}{retract}\PYG{p}{(}\PYG{n+nf}{stress}\PYG{p}{(}\PYG{n+nv}{Signature}\PYG{p}{,} \PYG{n+nv}{Count}\PYG{p}{))}
    \PYG{l+s+sAtom}{\PYGZhy{}\PYGZgt{}}  \PYG{n+nv}{NewCount} \PYG{o}{is} \PYG{n+nv}{Count} \PYG{o}{+} \PYG{l+m+mi}{1}
    \PYG{p}{;}   \PYG{n+nv}{NewCount} \PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{p}{),}
    \PYG{n+nf}{assertz}\PYG{p}{(}\PYG{n+nf}{stress}\PYG{p}{(}\PYG{n+nv}{Signature}\PYG{p}{,} \PYG{n+nv}{NewCount}\PYG{p}{)).}

\PYG{c+c1}{\PYGZpc{} \PYGZhy{}\PYGZhy{}\PYGZhy{} Public helpers for managing the stress map \PYGZhy{}\PYGZhy{}\PYGZhy{}}

\PYG{c+c1}{\PYGZpc{}!      get\PYGZus{}stress\PYGZus{}map(\PYGZhy{}Map:list) is det.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       Returns the current conceptual stress map as a list of}
\PYG{c+c1}{\PYGZpc{}       `stress(Signature, Count)` terms.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       @param Map A list containing all current stress facts.}
\PYG{n+nf}{get\PYGZus{}stress\PYGZus{}map}\PYG{p}{(}\PYG{n+nv}{Map}\PYG{p}{)} \PYG{p}{:\PYGZhy{}}
    \PYG{n+nf}{findall}\PYG{p}{(}\PYG{n+nf}{stress}\PYG{p}{(}\PYG{n+nv}{Signature}\PYG{p}{,} \PYG{n+nv}{Count}\PYG{p}{),} \PYG{n+nf}{stress}\PYG{p}{(}\PYG{n+nv}{Signature}\PYG{p}{,} \PYG{n+nv}{Count}\PYG{p}{),} \PYG{n+nv}{Map}\PYG{p}{).}

\PYG{c+c1}{\PYGZpc{}!      reset\PYGZus{}stress\PYGZus{}map is det.}
\PYG{c+c1}{\PYGZpc{}}
\PYG{c+c1}{\PYGZpc{}       Clears the entire conceptual stress map by retracting all `stress/2` facts.}
\PYG{n+nf}{reset\PYGZus{}stress\PYGZus{}map} \PYG{o}{:\PYGZhy{}}
    \PYG{n+nf}{retractall}\PYG{p}{(}\PYG{n+nf}{stress}\PYG{p}{(}\PYG{k}{\PYGZus{}}\PYG{p}{,} \PYG{k}{\PYGZus{}}\PYG{p}{)).}
\end{MintedVerbatim}
