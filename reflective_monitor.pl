:- module(reflective_monitor, [
    reflect/2,
    get_stress_map/1,
    reset_stress_map/0
]).

:- use_module(incompatibility_semantics).

% The stress map is a set of dynamic facts tracking which clauses cause failures.
% stress(ClauseSignature, Count)
:- dynamic stress/2.

% reflect(+Trace, -DisequilibriumTrigger)
%
% Analyzes an execution trace to detect disequilibrium.
% Disequilibrium is triggered by either a goal failure or a logical incoherence.
% If the system is in equilibrium, it succeeds silently.

reflect(Trace, Trigger) :-
    % 1. Parse the trace to extract commitments and failures.
    parse_trace(Trace, Commitments, Failures),

    % 2. Update the conceptual stress map based on failures.
    update_stress_map(Failures),

    % 3. Check for disequilibrium triggers.
    (
        % Trigger 1: Goal Failure
        Failures \= [],
        Trigger = goal_failure(Failures), !
    ;
        % Trigger 2: Logical Incoherence
        incoherent(Commitments),
        Trigger = incoherence(Commitments), !
    ).


% parse_trace(+Trace, -Commitments, -Failures)
%
% Recursively walks the trace structure generated by the meta-interpreter
% and extracts the list of commitments (clauses used) and failures.
parse_trace(Trace, Commitments, Failures) :-
    parse_trace_recursive(Trace, Commitments_Nested, Failures_Nested),
    flatten(Commitments_Nested, Commitments),
    flatten(Failures_Nested, Failures).

parse_trace_recursive([], [], []).
parse_trace_recursive([Event|Events], [Commitments|Other_Cs], [Failures|Other_Fs]) :-
    parse_event(Event, Commitments, Failures),
    parse_trace_recursive(Events, Other_Cs, Other_Fs).

% How to handle each type of trace event.
parse_event(trace(_, SubTrace), C, F) :- parse_trace_recursive(SubTrace, C, F).
parse_event(clause(Clause), [Clause], []).
parse_event(fail(Goal), [], [fail(Goal)]).
parse_event(call(_), [], []). % Built-in calls are not commitments in this context.


% update_stress_map(+Failures)
%
% For each failed goal, identify the clause signature and increment its stress level.
update_stress_map([]).
update_stress_map([fail(Goal)|Failures]) :-
    functor(Goal, Name, Arity),
    increment_stress(Name/Arity),
    update_stress_map(Failures).

increment_stress(Signature) :-
    (   retract(stress(Signature, Count))
    ->  NewCount is Count + 1
    ;   NewCount = 1
    ),
    assertz(stress(Signature, NewCount)).

% --- Public helpers for managing the stress map ---

% get_stress_map(-Map)
%
% Returns the current conceptual stress map as a list of stress(Signature, Count).
get_stress_map(Map) :-
    findall(stress(Signature, Count), stress(Signature, Count), Map).

% reset_stress_map
%
% Clears all stress counters.
reset_stress_map :-
    retractall(stress(_, _)).