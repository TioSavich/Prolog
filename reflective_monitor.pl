/** <module> Reflective Monitor for Disequilibrium Detection
 *
 * This module implements the "Reflect" stage of the ORR cycle. Its primary
 * role is to analyze the execution trace produced by the meta-interpreter
 * (`meta_interpreter.pl`) and detect signs of "disequilibrium."
 *
 * Disequilibrium can manifest in two main ways:
 * 1.  **Goal Failure**: The system was unable to find a proof for the goal.
 * 2.  **Logical Incoherence**: The proof that was found relies on a set of
 *     commitments (clauses) that are logically inconsistent with each other,
 *     as determined by `incompatibility_semantics.pl`.
 *
 * This module also maintains a "conceptual stress map," which tracks how
 * often certain predicates are involved in failures. This map can be used by
 * the reorganization engine to guide its search for a solution.
 *
 * The stress map is stored as dynamic facts of the form:
 * `stress(PredicateSignature, Count)`.
 *
 * @author Tilo Wiedera
 * @license MIT
 */
:- module(reflective_monitor, [
    reflect/2,
    get_stress_map/1,
    reset_stress_map/0
]).

:- use_module(incompatibility_semantics).

:- dynamic stress/2.

%!      reflect(+Trace:list, -DisequilibriumTrigger:term) is semidet.
%
%       Analyzes an execution trace from the meta-interpreter to detect
%       disequilibrium. It succeeds if a trigger for disequilibrium is found,
%       binding `DisequilibriumTrigger` to a term describing the issue. It
%       fails if the trace represents a state of equilibrium (i.e., the goal
%       succeeded and its premises are coherent).
%
%       The process involves:
%       1. Parsing the trace to separate successful commitments from failures.
%       2. Updating a conceptual stress map based on any failures.
%       3. Checking for disequilibrium triggers, prioritizing goal failure over
%          incoherence.
%
%       @param Trace The execution trace generated by `solve/4`.
%       @param DisequilibriumTrigger A term describing the reason for
%       disequilibrium, e.g., `goal_failure([...])` or `incoherence([...])`.
reflect(Trace, Trigger) :-
    % 1. Parse the trace to extract commitments and failures.
    parse_trace(Trace, Commitments, Failures),

    % 2. Update the conceptual stress map based on failures.
    update_stress_map(Failures),

    % 3. Check for disequilibrium triggers.
    (
        % Trigger 1: Goal Failure
        Failures \= [],
        Trigger = goal_failure(Failures), !
    ;
        % Trigger 2: Logical Incoherence
        incoherent(Commitments),
        Trigger = incoherence(Commitments), !
    ).


% parse_trace(+Trace, -Commitments, -Failures)
%
% Recursively walks the trace structure generated by the meta-interpreter
% and extracts the list of commitments (clauses used) and failures.
parse_trace(Trace, Commitments, Failures) :-
    parse_trace_recursive(Trace, Commitments_Nested, Failures_Nested),
    flatten(Commitments_Nested, Commitments),
    flatten(Failures_Nested, Failures).

parse_trace_recursive([], [], []).
parse_trace_recursive([Event|Events], [Commitments|Other_Cs], [Failures|Other_Fs]) :-
    parse_event(Event, Commitments, Failures),
    parse_trace_recursive(Events, Other_Cs, Other_Fs).

% How to handle each type of trace event.
parse_event(trace(_, SubTrace), C, F) :- parse_trace_recursive(SubTrace, C, F).
parse_event(clause(Clause), [Clause], []).
parse_event(fail(Goal), [], [fail(Goal)]).
parse_event(call(_), [], []). % Built-in calls are not commitments in this context.


% update_stress_map(+Failures)
%
% For each failed goal, identify the clause signature and increment its stress level.
update_stress_map([]).
update_stress_map([fail(Goal)|Failures]) :-
    functor(Goal, Name, Arity),
    increment_stress(Name/Arity),
    update_stress_map(Failures).

increment_stress(Signature) :-
    (   retract(stress(Signature, Count))
    ->  NewCount is Count + 1
    ;   NewCount = 1
    ),
    assertz(stress(Signature, NewCount)).

% --- Public helpers for managing the stress map ---

%!      get_stress_map(-Map:list) is det.
%
%       Returns the current conceptual stress map as a list of
%       `stress(Signature, Count)` terms.
%
%       @param Map A list containing all current stress facts.
get_stress_map(Map) :-
    findall(stress(Signature, Count), stress(Signature, Count), Map).

%!      reset_stress_map is det.
%
%       Clears the entire conceptual stress map by retracting all `stress/2` facts.
reset_stress_map :-
    retractall(stress(_, _)).