/** <module> Learned Knowledge Base (Auto-Generated)
 *
 *  DO NOT EDIT THIS FILE MANUALLY.
 *
 *  This file serves as the persistent memory for the `more_machine_learner`.
 *  It stores the clauses for the dynamic predicate `run_learned_strategy/5`
 *  that the system discovers and validates through its generative-reflective
 *  exploration process.
 *
 *  The contents of this file are automatically generated by the
 *  `save_knowledge/0` predicate in `more_machine_learner.pl` and are
 *  loaded automatically when the system starts. Any manual edits will be
 *  overwritten.
 *
 * @author More Machine Learner (Auto-Generated)
 * 
 */

% Automatically generated knowledge base.
:- op(550, xfy, rdiv).

% --- Arithmetic Strategy Rules ---
run_learned_strategy(A, B, C, rmb(10), D) :-
    integer(A),
    integer(B),
    A>0,
    A<10,
    E is 10-A,
    B>=E,
    F is B-E,
    C is 10+F,
    D=trace{a_start:A, b_start:B, steps:[step(A, 10), step(10, C)], strategy:rmb(10)}.
run_learned_strategy(A, B, C, doubles, D) :-
    integer(A),
    A==B,
    C is A*2,
    D=trace{a_start:A, b_start:B, steps:[rote(C)], strategy:doubles}.
run_learned_strategy(A, B, C, cob, D) :-
    integer(A),
    integer(B),
    (   A>=B
    ->  E=A,
        F=B,
        G=no_swap
    ;   E=B,
        F=A,
        G=swapped(B, A)
    ),
    (   G=swapped(_, _)
    ->  (   proves(([n(plus(A, B, H))]=>[n(plus(B, A, H))]))
        ->  true
        ;   fail
        )
    ;   true
    ),
    solve_foundationally(E, F, C, I),
    D=trace{a_start:A, b_start:B, steps:[G, inner_trace(I)], strategy:cob}.

% --- Proof Strategy Rules (from v2) ---
learned_proof_strategy(goal{context:[n(is_complete(A))], vars:[A, B]}, introduce(n(euclid_number(B, A)))) :-
    incompatibility_semantics:product_of_list(A, C),
    B is C+1,
    B>1.
learned_proof_strategy(goal{context:[n(euclid_number(A, B))], vars:[A, B]}, case_split(n(prime(A)), n(composite(A)))).
